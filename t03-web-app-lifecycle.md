# 継続トレーニング #3：Webアプリケーションのライフサイクル -- 動的コンテンツと静的コンテンツ、CGI、Webアプリケーションサーバ、インジェクション攻撃

## 概要

前回のプロセスの話の続きで、
今回もプログラムがどこでどう動いているのかの話として、
主にWebサーバとクライアントの相互作用についてお話します。
前回たどり着けなかったインジェクション攻撃の話もします。
また、コンテンツ生成という観点で、
動的なコンテンツだけでなく静的なコンテンツにも触れ、
次回予定しているHTTPの話に繋げていきます。

### 本日お話すること

* Webアプリケーションと静的コンテンツと動的コンテンツ
  * 静的コンテンツとバッチ処理
  * 静的コンテンツがよいか動的コンテンツがよいか
* WebサーバでCGIを動かしてみる
* Webアプリケーションサーバを動かしてみる
* JavaScriptのライフサイクル
* インジェクション攻撃
* 「世界最悪のログイン処理コード」の世界を理解する


## 前回のおさらい

前回は次のようなことを学んだ。はず。

* プログラムは実行されるとメモリ上のプロセスとなって動く。
* 同じプログラムを複数同時に実行すると、複数のプロセスが立ち上がる。
  それらは独立で、異なるPIDをもつ。
* ディスク上のプログラムを書き換えても、影響が出るのは書き換えた後に起動したプロセスのみ。
  すでに読み込まれて動いているプロセスでは古い内容のものが実行され続ける。
* 無限ループにより、基本的に永遠に終わらないのが常駐プログラム、デーモン、サーバである。
* 永遠に終わらないプログラム（プロセス）を止めるには、`kill`等で外からシグナルを送る。

これは、macOSやLinuxサーバ環境、FreeBSDサーバ環境等、
Unix系OSでのプログラムのライフサイクルであった。

これらの話が何に繋がるか？

* 書かれているもの（見えるもの）と動いているもの（見えないもの）の違いに起因する問題に、
  対応できる（原因として想像できる）。
* コンピュータが忙しそうにしているときに、何が忙しいのかチェックできる。
  （macOSならアクティビティモニタ、Windowsの場合だとタスクマネージャーがあるけど。）

↓小林のMacのファンがうるさいとき

```
USER               PID  %CPU %MEM      VSZ    RSS   TT  STAT STARTED      TIME COMMAND
noritada          1338 113.4  3.9  6437000 656212   ??  R    水11AM  20:09.76 /Applications/Google Chrome.app/Contents/Frameworks/Google Chrome Framework.framework/Versions/78.0.3904.70/Helpers/Google Chrome Helper (Renderer).app/Contents/MacOS/Google Chrome Helper (Renderer) --type=renderer --field-trial-handle=1718379636,10374553573568034758,335896188464633298,131072 --lang=ja --metrics-client-id=e0f46667-fa1f-4d7a-a671-c8a631f42be5 --extension-process --enable-auto-reload --num-raster-threads=2 --enable-zero-copy --enable-gpu-memory-buffer-compositor-resources --enable-main-frame-before-activation --service-request-channel-token=9969976410932607611 --renderer-client-id=52 --no-v8-untrusted-code-mitigations --seatbelt-client=205
noritada          1527 110.9  8.0  7392920 1349136   ??  R    水11AM  35:35.64 /Applications/Google Chrome.app/Contents/Frameworks/Google Chrome Framework.framework/Versions/78.0.3904.70/Helpers/Google Chrome Helper (Renderer).app/Contents/MacOS/Google Chrome Helper (Renderer) --type=renderer --field-trial-handle=1718379636,10374553573568034758,335896188464633298,131072 --lang=ja --metrics-client-id=e0f46667-fa1f-4d7a-a671-c8a631f42be5 --extension-process --enable-auto-reload --num-raster-threads=2 --enable-zero-copy --enable-gpu-memory-buffer-compositor-resources --enable-main-frame-before-activation --service-request-channel-token=11023647874178712406 --renderer-client-id=49 --no-v8-untrusted-code-mitigations --seatbelt-client=238
noritada          1259  25.2  4.2  7391440 704704   ??  S    水11AM 188:43.56 /Applications/Google Chrome.app/Contents/MacOS/Google Chrome
noritada         20378  18.9  0.1  4975568  15960   ??  R    金02PM 393:56.32 /Applications/Google Chrome.app/Contents/Frameworks/Google Chrome Framework.framework/Versions/78.0.3904.70/Helpers/Google Chrome Helper (Renderer).app/Contents/MacOS/Google Chrome Helper (Renderer) --type=renderer --field-trial-handle=1718379636,10374553573568034758,335896188464633298,131072 --lang=ja --metrics-client-id=e0f46667-fa1f-4d7a-a671-c8a631f42be5 --enable-auto-reload --num-raster-threads=2 --enable-zero-copy --enable-gpu-memory-buffer-compositor-resources --enable-main-frame-before-activation --service-request-channel-token=5444330101072567 --renderer-client-id=1203 --no-v8-untrusted-code-mitigations --seatbelt-client=170
```

## Webアプリケーションと静的コンテンツと動的コンテンツ

Webで提供されるコンテンツは、
**「静的コンテンツ (static contents)」** と **「動的コンテンツ (dynamic contents)」** に分けられる。

* 静的コンテンツ：
  固定のHTMLファイルや画像など、サーバに保存されているファイル（データ）を出すだけで、
  表示も変わらないもの
* 動的コンテンツ：以下の2種類がある
  * サーバ側でプログラムが走り、ユーザからHTTPリクエストを受けたタイミングで、
    コンテンツを作り出して返すもの（サーバサイドの動的コンテンツ）
  * HTMLやその他データ自体は静的だが、HTMLを表示した後、
    ブラウザ上でのユーザのマウス操作などに応じてJavaScriptやFlashなどのプログラムが走り、
    コンテンツが変化するもの（クライアントサイドの動的コンテンツ）

### 静的コンテンツとバッチ処理

「静的コンテンツ」が「固定のHTMLファイルや画像など」を指すとは言え、
24時間365日、ユーザにとって常に同じものが見えるとは限らない。
たとえば、レーダーの画像ファイルを1時間に一度、同じ名前で作り置きしていれば、
静的コンテンツとはいえ、目にする人にとってはコンテンツは時間とともに変化する。
（駅のデジタルサイネージは基本的にこのタイプで、
数枚の画像を定期的に更新しているだけだろう。）

「1時間に一度、まとめて作り直す」のような、
定期的にまとめて行う処理を **バッチ処理** と呼ぶ。

### 静的コンテンツがよいか動的コンテンツがよいか

同じサーバサイドで作るコンテンツでも、
動的コンテンツとして、ユーザからリクエストが来るたびに作り直すのがよいか、
バッチ処理で静的コンテンツとして生成するのがよいかは、コンテンツの性質に依存する。

#### 静的コンテンツのバッチ処理での生成

特徴：

* コンテンツのデータを生成するコストは低い
  * リクエストを受けたときにすることは、すでに作り置きされているものを出すだけ
* コンテンツのデータを保存し、不要になったデータを削除するなどの、
  データの管理コストはかかる
  * データの削除を忘れると、絶対に使われない古いデータが溜まり続ける

向いているもの：

* ユーザによって変える必要がないコンテンツ
  * もちろん、「ユーザによって変える必要がないコンテンツ」を作った上で、
    表示の部分だけ動的にする（たとえばユーザの地域で表示を何パターンかに分ける）」
    などは可能
  * キャッシュも効かせやすい
* 作るのに時間がかかるもの
    * たとえば、データの生成に30秒かかるようなコンテンツを、
      ユーザからのリクエストを受けるたびに作るのは厳しい
      （もちろん、そういうサービスと割り切れるものなら問題ない）
* 定期的に更新するもの

#### 動的な生成

特徴：

* コンテンツのデータを生成するコストは高い
  * 少しでも表示に時間がかかれば、それだけユーザに不便を感じさせる
* コンテンツのデータを保存し、不要になったデータを削除するなどの、
  データの管理コストはない
  * 作られた、メモリ上にあるデータをそのまま出すだけで、それをどこかに保存はしない

向いているもの：

* 膨大な条件によって出し分けるコンテンツ
  * たとえば、完全に個々のユーザごとであり、他のユーザとの共通要素がないコンテンツ
* 常に変化するコンテンツ

#### 実際は組み合わせ

たとえば「ユーザのいる都道府県によってレーダー画像を出す」場合の例：

* レーダー画像はすべての都道府県の分をバッチ処理で更新しておく（静的コンテンツのバッチ生成）
* ユーザの位置情報（緯度経度）をブラウザからサーバに送信（クライアントサイド動的コンテンツ）
* サーバ内で、位置情報をもとに都道府県を決定して、その画像の場所（パス）をブラウザに返す
  （サーバサイド動的コンテンツ）


## WebサーバでCGIを動かしてみる

サーバサイドの動的コンテンツの例としてCGIを説明する。

**CGI (Common Gateway Interface)** は、
ユーザからアクセスがあったタイミングでプログラムが実行され、
標準入力を入力とし、標準出力への出力内容がユーザへのレスポンスとなる仕組み。

CGIは、Webサーバがリクエストを受け、
WebサーバがURLに応じて「サーバサイドの普通のプログラム」を立ち上げるかたちとなっている。
つまり、連携する2つの部品から成っている。

* ApacheなどのWebサーバ（大抵はサードパーティーの製品）
* サービス提供側の開発者が書いた「普通のプログラム」

メリット：

* コマンドラインから簡単に動作を確認できるので、配置が簡単
* 標準入出力を扱う普通のプログラムなので、実装が簡単
* 標準入出力を扱う普通のプログラムなので、どのような言語でも簡単に実装可能

デメリット：

* アクセスのたびにプログラムが起動する（プロセスが立ち上がる）
  （ふだんプログラムを実行しているとあまり意識しないかもしれないが、
  プロセスが立ち上がるのには少し時間がかかる。
  たとえば同時アクセス数が千単位、万単位になると影響が出てくる。）
* 機能ごとに個別のプログラムとなるため、全体の連携がしにくい

ハンズオン：
* 準備：今回の教材を手に入れる
* 演習1：WebサーバでCGIを動かしてブラウザの表示とプロセスを確認してみる
* 演習2：WebサーバでコマンドラインからCGIのプログラムを実行してみる


## Webアプリケーションサーバを動かしてみる

最近は動的なコンテンツが増え、コンテンツ間の連携も必要になるため、
CGIはあまり使われなくなってきており、
代わりに **Webアプリケーションサーバ** という仕組みがよく使われる。
これも、サーバサイドの動的コンテンツの一つの例である。

CGIとは異なり、Webアプリケーションサーバは、
全体が1つのプログラムとなっている。
とはいっても、大きくは2つの部品から成る。

* URLと機能をつなぐ仕組み（フレームワーク）などを提供するライブラリ
* ライブラリを用いてサービス提供側の開発者が書いたアプリケーションプログラム

メリット：

* リクエストを受けるのもサーバ自体となるため、
  アクセスのたびにプログラムが起動するようなことはない
* 機能が相互に連携しあう大きなアプリケーションプログラムが書ける

デメリット：

* ライブラリを含む様々なファイルがないと機能しないので、
  個別に開発することが厳しく、一部の変更が全体に波及しやすい
* ライブラリを含む様々なファイルがないと機能しないので、配置に注意が必要となる。

ハンズオン：
* 演習3：Webアプリケーションサーバを動かしてブラウザの表示とプロセスを確認してみる（シングルスレッド）
* 演習4：Webアプリケーションサーバを動かしてブラウザの表示とプロセスを確認してみる（マルチスレッド）


## JavaScriptのライフサイクル

サーバ側の言語は基本的にOS上で実行され、プロセスというかたちをとって、
「上から順」に実行されていく。
クライアント側のブラウザ上で動くJavaScriptは少し異なる。

JavaScriptはイベントドリブンで、HTML上のさまざまな要素にイベントハンドラを設定し、
そのイベントが起きたタイミングで実行される。

（絵を描くので、絵を参照してください。。。）


## 不正な文字列の埋め込み

ユーザの入力をそのままサーバの中でのSQL文やコマンドに埋め込むと、
意図しないコマンドの実行などをされることがある。

よくあるのがSQLインジェクションである。

ハンズオン：
* 演習5：不正な文字列の埋め込み


## 「世界最悪のログイン処理コード」の世界を理解する

「世界最悪のログイン処理コード」として一時期話題になった[コード](https://www.reddit.com/r/programminghorror/comments/66klvc/this_javascript_code_powers_a_1500_user_intranet/)がある。

これの何が問題なのか、考えてみるとよい。

![](images/t03-client-login.png)
