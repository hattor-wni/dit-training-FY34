# 継続トレーニング #4：HTTPとWeb API -- HTTPの構成要素、Web API、RESTful

## 概要

今回はHTTPのお話をします。
目的は、社内や社外のRESTful Web APIを叩けるようになることです。
叩き間違えてうまくいかないこともあるはずなので、
叩くのに使われるHTTPというプロトコルの構成要素についてもお話をします。
また、「RESTful Web API」と「REST」を強調することが結構ありますが、
RESTの意味や、RESTfulでないAPIについてはあまり触れられることがないので、
そのあたりもお話をします。
前回までの話は、一部関係するところもありますが、大半は前提としません。

EXPO（Legacy含む）のAPIの細かい機能紹介のようなものは、
また別途（テクニカルサークルか継続トレーニングで）場を設けて行うつもりです。
今回は、その前の段階として、HTTPを使ってWebAPIを叩き、
うまくいかなくてもある程度自分でどうにかできるようになるのが目的です。

### 本日お話すること

* 社内のWeb APIを叩いてみる
* APIとは？
  * API = Application Programming Interface
* APIの前にInterfaceについて
  * interface = inter + face
  * さまざまなインタフェース
  * 公開されたインタフェースの例（開発と関係のない説明）
  * よくないインタフェース
* ふたたびAPI
  * 【余談】APIの「使いやすさ」：型
  * 【余談】APIの「使いやすさ」：欠測値
  * Web以外のAPI
* Web APIとは？
  * ユースケース
  * Web APIとはもう少し具体的にどんなものか
  * Web APIがあると何がよいか？
  * Web APIを使わずにデータを抽出する
  * 【余談】stockにはAPIがない
* RESTful Web APIとは？
  * RESTとは？
  * RESTfulでないWeb APIとは？
* HTTPの構成要素
  * メソッドとパス
  * ヘッダ
  * ボディ
  * ステータス
* curlを使ってHTTPを眺める


## 社内のWeb APIを叩いてみる

コマンドラインから下記を叩いてみよう！（社内のサーバでないとアクセスできないはず。）

```
curl -X GET "https://api.test-legacy.wni.com/v1/catalog"
```

## APIとは？

### API = Application Programming Interface

APIは、アプリケーションのプログラミング用のインタフェース。
と言ってわかる人はいいが、イメージが湧かないかもしれない。

一言でいうと：

> ソフトウェアやサービスをプログラムから使えるように定めた、
> 「この機能にこれを入力として与える（引数として渡す）とこれが出力される（値が返ってくる）」
> といったような規約の集合

◆参考：[API -- MDN Web Docs 用語集: ウェブ関連用語の定義](https://developer.mozilla.org/ja/docs/Glossary/API)

具体的には、利用可能な「関数」などを集めたようなもの。ライブラリと同類。

◆参考：Pythonの標準ライブラリ ( [en](https://docs.python.org/3/library/) / [ja](https://docs.python.org/ja/3/library/) )

あとでもう少し詳しく見る。
まずはApplication Programming Interfaceという言葉のうち、特にinterfaceについて、
もう少し詳しく掘り下げる。


## APIの前にInterfaceについて

### interface = inter + face

[inter-](https://www.lexico.com/en/definition/inter-)

> PREFIX
> 1. Between; among.
>
>   ‘inter-agency’
>   ‘interblend’
> 2. Mutually; reciprocally.
>
>   ‘interactive’

internationalは1番、interactは2番。
interfaceは1番。

### さまざまなインタフェース

インタフェースという言葉は、技術の世界では様々なところで登場する。
いずれの場合も「インタフェース」と略される。

◆参考："Interface (computing)" in Wikipedia ( [en](https://en.wikipedia.org/wiki/Interface_(computing)) / [ja](https://ja.wikipedia.org/wiki/%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9_(%E6%83%85%E5%A0%B1%E6%8A%80%E8%A1%93)) )

* Hardware Interface
  * 「規格」という言葉を使うとおそらくわかりやすい
  * HDMI (High-Definition Multimedia Interface) のIもinterface
* Software Interface
  * API
* User Interface (UI)
  * Human-Machine Interface (HMI)
    * [AppleのHuman Interface Guidelines](https://developer.apple.com/design/human-interface-guidelines/)
  * [Graphical User Interface (GUI)](https://en.wikipedia.org/wiki/Graphical_user_interface)
  * Command-line Interface (CLI)

### 公開されたインタフェースの例（開発と関係のない説明）

例えばA社という会社の窓口（社外とのインタフェース）としては、
会社の電話番号やメールアドレス、ウェブサイトが公開されている。
そういった窓口で「社員数は何人ですか？」ときけば、きちんとした答えをもらえる。
もし間違った情報が返ってきたら、それは「バグ」であり、大抵の場合は修正される。
大きな問題を修正せずに放置していたら、おそらくその会社の品質は疑問をもたれる。

一方で、A社に努めている自分の個人的な知り合いの太郎さんは、自分にとってA社の窓口。
彼に色々訊けば、会社のことを教えてもらえるかもしれない。
しかしそのインタフェースは非公式なインタフェース。
太郎さんの教えてくれる情報は、正しいかもしれないが、間違っているかもしれない。
「社員数は何人ですか？」「900人……（だったはず……）です……」
たとえ間違っていたとしても、太郎さんには修正する責任はない。

公式なインタフェースでない「裏口」の窓口は、色々な都合で勝手になくなるかもしれない。
「太郎さん、A社の社員数について質問があるんだけど……」
「ごめん、もう1年前にやめてB社にいるので、最新のことはわからない」
太郎さんは公式として定められていない窓口。
太郎さんがいる間は使えることはわかっている。
けど非公式だし、機能も保証されているわけではない。
もちろん、会社の公式な窓口は、そう簡単にはなくなったりしない。

外に公開されたインタフェースと公開されていないインタフェースとはそういうもの。

* インタフェースを公開するとは、少なくとも一定の期間、その方法でその機能（何らかの情報へのアクセスや、データの操作など）が使えることを保証するということ（もちろん、免責事項をつけたりすることはある）
* 公開されていないインタフェースを使うとは、今は使えるかもしれないけど、いつ使えなくなるかわからないものを使うということ

### よくないインタフェース

「この方法でアクセスできるって書かれていたけど」
「ごめん、先日から方法が変わって、今はこうなっている。でも明日からはこうなるよ」
インタフェースがコロコロ変わるのはよくない。

アプリケーションの機能は時間とともに変わるもの。
でも、あまりにもコロコロ変わるのはユーザにとって困る。
「この機能を使って1ヶ月後にリリース予定のアプリを作りたいんだけど、
1ヶ月後もこの機能は使えるのだろうか？」


## ふたたびAPI

話をAPIに戻す。
APIとはプログラミングインタフェースなので、プログラムから扱いやすく作られている。

たとえば、注文内容を返すAPIを考える。
返す情報は以下の情報をすべての商品について列挙したものにしたい。

* 注文日時
* 商品名
* 単価
* 個数

どんなデータが返ってくると嬉しいだろうか。

* [案1](t04/samples/sample.txt)
* [案2](t04/samples/sample.html)
* [案3](t04/samples/sample2.html)
* [案4](t04/samples/sample.csv)
* [案5](t04/samples/sample.json)
* [案6](t04/samples/sample2.json)

HTMLは人間でなくプログラムが読むもの。確かにそれはそう。
いきなりHTMLを紙に手書きして渡してくるような人はいない。たぶん。
でも、自分が使う立場として、HTMLを返されてそれを使うのとJSONを返されてそれを使うの、
どちらが嬉しいだろうか？

### 【余談】APIの「使いやすさ」：型

プログラミングを始めたときに、おそらく最初に出会う概念は「型」だろう。
数値の`1`と文字列の`"1"`では、意味も異なるし扱える操作も異なる。
データを扱うときに、それがどんな型かは重要。

たとえばJSONには簡単な型がいくつかある。
数値、文字列、など。
これはつまり、JSONをパース（解析）してくれるライブラリは、
JSON内に`1`という数値があった場合はそれを数値として使えるようにしてくれるし、
`"1"`という文字列があった場合はそれを文字列として使えるようにしてくれる。

一方でCSVには基本的に型がない。
CSVをパースしてくれるライブラリの中には、
型を自動的に推測して変換してくれるものや、
フィールド（カラム）ごとに型を指定できるものもあるが、
シンプルなライブラリでは文字列にしかしてくれない。
数値などには自分で変換する必要がある。

### 【余談】APIの「使いやすさ」：欠測値

気象要素の観測値のようなデータを扱う場合、
「欠測値」というものをしばしば取り扱わないといけない。

「観測できなかったならデータとして出さなければいいのでは」
と思うかもしれないが、そんなわけにもいかない。
たとえば気温は測れたけど、風速は測れなかった、という場合もある。
それに、定期的に測っているデータに関して、
測れなかったからといってデータを送らなかったら、
データを受ける方は、通信に問題があるのか観測機に問題があるのかわからない。

欠測値の表現は悩ましい問題。

考えられる表現：

* `-`のように非数値を入れたり空欄にする
* 999のように絶対にありえない（999℃！）数値を入れておく
* 正しく観測されたかどうかという情報を数値とは別に持たせる

1つ目の場合、「ここには数値が入る」という前提でデータを読んでいくと失敗する。
自前のプログラムで読む場合、 **失敗するので気付ける** というメリットはある。
しかし、一々数値か文字列かをチェックするために`if`文などを書くのは、
データが増えた場合に非常に非効率となる。
型が混ざっているというのは、強い型付けをもつ言語ではプログラムが複雑になりがち。

2つ目は、何も知らずにデータを表示すると大きな問題になる。
「999℃と出してしまった」のようなコンテンツ生成上の失敗談は多い。
999かどうかという、「値」による場合分けは（先程の型による場合分けよりも）非常に簡単だが、
たとえば「元々は想定していなかった1000mmという日雨量が発生してしまった」のような、
値の設定ミスも起こりうる。

3つ目は、おそらく最も無難ではある。
何も気にせず数値は数値として読めるし、
正しく観測されたかどうかというフラグも最初から出しておけば、
「欠測値を意味する値が入ることがあるなんて……」というような、
知らなかったが故の問題も起きにくい。
2つの情報を使うことで若干冗長になり、データサイズが少し膨らむのが玉にキズ。

### Web以外のAPIの例

Web APIを理解する前に、Web以外のAPIとはどんなものがあるかを理解しておいたほうがよい。

#### DOM

HTMLの中身のデータに、統一された方法でアクセスするためのモデル。
これを実装したライブラリであれば、どのようなプログラミング言語のライブラリだろうと、
読み込んだHTMLの中から指定した情報（たとえば「すべての`<img>`タグの`src`属性」や「`id`が`last_updated`である要素」など）に同じようにアクセス可能。
ライブラリごとに違ったら、ちょっとしたことをするにも一々調べないといけない。

#### POSIX

LinuxやFreeBSD、macOS（のコアとなるDarwin）など、
さまざまなUnix系OSの共通の機能などを定めたもの。
たとえば、macOSでもLinuxでも`ls`コマンドもあるし、
`/hoge/fuga`のような同じようなディレクトリ構造となっている。
システムコールと呼ばれる、アプリケーションがOSに対して出す命令群も共通。

#### Windows API

Windowsのアプリケーションを作るためのAPI。
それぞれの商用OSについてはこのようなAPIが公開されているので、
ユーザはそのOSのソースコードを見ずに、OSの機能を使ってアプリケーションを作れる。


## Web APIとは？

Web APIとは、ふつうのWebアプリケーション同様、HTTPとURLを使って利用できるAPI。

### ユースケース

「Web APIを提供する」というとき、大抵の場合は人間向けのサービスがすでにある。
そういう人間向けのサービスを提供していると、
「一々ログインしてマウス操作でやるのは辛い」
「人間の手で1つ1つ作業するのは辛い」
ということが出てくる。

* 携帯電話の使用量を毎日チェックしたい
* 特定の商品の売れ行きランクを毎日チェックしたい
* カレンダーから予定の一覧を抽出したい

そういうものをプログラムから操作できるように提供するのがWeb API。

* 携帯電話の使用量をデータとして返す機能
* 特定の商品の売れ行きランクをデータとして返す機能
* カレンダーから予定の一覧をデータとして返す機能

### Web APIとはもう少し具体的にどんなものか

* こういうURLにGETメソッドでアクセスすると、こういうリストが得られる
* こういうURLの最後にidをつけてGETメソッドでアクセスすると、このidの情報が見られる
* こういうURLにPUTメソッドででこういう情報を送ると、その情報がリストに追加される
* こういうURLにDELETEメソッドでこういう情報を送ると、その情報が消される
* こういうURLの最後にidをつけてGETメソッドでアクセスしたが、そのidが存在しない場合、
  こういうコードが返ってくる

例：

* Amazonの商品のAPI
  * Web APIの流行りのきっかけ
* Google APIs
  * Google MapsをHTMLに埋め込んだり、マップ上にピンを配置して場所を示すのも、APIの一つ
  * [Google Calendar API](https://developers.google.com/calendar)
    * 各言語用のライブラリなどを使った例もクイックスタートで紹介](https://developers.google.com/calendar/quickstart/js)
    * カレンダーをHTMLに埋め込むのもAPIの一つ
  * [YouTube IFrame Player API](https://developers.google.com/youtube/iframe_api_reference)：YouTubeの動画をWebページに埋め込めるやつ
* Twitter API
* [GitHub API](https://developer.github.com/v3/)
* [Slack API](https://api.slack.com/)

### Web APIがあると何がよいか？

Web APIの多くは、大体こんな目的で提供されている。

* 上で書いたとおり、既存のWebアプリケーションの機能を自動化できる。
* 公式にはなかなかやりにくい他社サービスとの連携（**マッシュアップ**）ができる。
  * 例：自社サイトや社内サイトにGoogle Calendarを埋め込む
  * 例：GitHubの新たなIssue登録やPull RequestなどをSlackに流す
* 自動化やマッシュアップが可能になると、
  色々便利なものや面白いものを作って世の中に公開してくれる人が現れる。
  * そうすると目にする機会が増え、「使ってみようかな」という人が現れてユーザが増える。
  * APIの使用を登録制にして、
    「APIでユーザが作ってくれたツールの一覧」をまとめているサービスもある。
    * Google Chromeの拡張機能などもその例。
    * エコシステムができる。
    * ユーザ名も公開すれば、コミュニティの形成にも繋がる。

世の中には、他者実現したい人たちがたくさんいる。
そういう人たちのエネルギーを巻き込むのがAPI。

もちろん、
「使われたものの見返りがなく、サーバアクセス増加、インフラ増強によるコスト増加だけ」
になるリスクはある。
データを大量に抜き取られるだけの可能性もある。
そのため、Web APIを提供している会社では大抵の場合、
なるべくエコシステムなどに繋げられるよう、様々な工夫をしている。


### Web APIを使わずにデータを抽出する

今は、Seleniumのようなソフトウェアによって、
ブラウザのマウス操作を自動化することができるようになっている
（WebアプリケーションのUIのテストに用いられている）。

あるいは、JavaScriptを使っていない単なるHTMLのページなら、
HTMLを機械的に読み込んでデータを抜き取ることができる
（ブラウザのHTML解析部分がやっていること）。
**スクレイピング** という。

問題点：

* ユーザ側にとっての問題点：
  * データの解析に多少の手間がかかる。
  * あくまで非公式な方法なので、長期間その方法でアクセスできることが保証されていない。
    * ブラウザの操作は、画面のレイアウトが変わればボタンなどの位置も変わるもの。
    * HTMLについても、タグや構造が変われば解析してもデータにたどり着けない。
  * つまり初期コストがかかる上に保守も多い可能性がある。
* サービス提供側にとっての問題点：
  * 一般的に、「欲しいデータ」よりもいろいろな情報を含んでおり、
    サイズの大きなデータを返すことになるため、
    「人間の手を煩わせないから」といって大量にアクセスされるとWebサーバに負荷がかかる。
  * そもそも人間の手でアクセスすることを想定した負荷を前提として作られている。
  * 上記のような理由から、機械によるアクセスを条項で禁止したり、
    機械によると見られる場合に確認ページなどに飛ばすようにしているサービスも多い。

こういった問題点を回避するために、
わざわざデータ専用のインタフェースを設けているのがWeb APIである。

### 【余談】stockにはAPIがない

たとえば、社内に配信したデータのアーカイブであるstock DBにはAPIは存在しない。

社内には公式なData Catalogがあり、
stock DBの最近のデータを辿れるリンクはそのData Catalogからリンクされている。
したがって、stockは「データ」に対するWebインタフェースではある。
とはいえ、下記の問題がある。

* 古いものやデータの重要度によってはリンクが辿れないかもしれない
  （保証されているわけではない）
* データの日時によってツリーが異なるし、目で見て判断しないといけない
* 明文化されているわけではない（「ノウハウ」としての文章ならあるかも。でもそれはノウハウ）

先程、インタフェースの説明のところで、
少なくとも一定の期間、その方法で何かの情報にアクセスしたり、操作したりといったことが、
認められるということが大切、という話をした。
また、特にAPIではプログラムから扱えることが重要という話をした。
そのような意味で、上記は保証はされているが、プログラムから扱いやすいわけではない。
したがって、Webインタフェースだが、Web APIではない。


## RESTful Web APIとは？

### RESTとは？

REST = Representational State Transfer (REST)

少し古いが、[『Webを支える技術 ── HTTP，URI，HTML，そしてREST』](https://gihyo.jp/assets/images/cover/2010/9784774142043.jpg)を読むのが一番早い気がする。

↓特にこのあたり

```
第2章　Webの歴史
2.1　Web以前のインターネット
2.2　Web以前のハイパーメディア
Memex ── ハイパーメディアの起源
Xanadu ── 「ハイパーメディア」という言葉の誕生
HyperCard ── 初の実用的なハイパーメディア
Web以前のハイパーメディアの問題点
2.3　Web以前の分散システム
集中システムと分散システム
RPC ── ほかのコンピュータの機能を利用
CORBA，DCOM ── 分散オブジェクトへの進化
Web以前の分散システムの問題点
2.4　Webの誕生
ハイパーメディアとしてのWeb
分散システムとしてのWeb
2.5　Webの標準化
Webの仕様策定
RESTの誕生
さまざまなハイパーメディアフォーマットの誕生
2.6　Web APIをめぐる議論
SOAPとWS-*
SOAP対REST
RESTの誤解と普及
SOAPとWS-*の敗因
2.7　すべてがWebへ
第3章　REST ── Webのアーキテクチャスタイル
3.1　アーキテクチャスタイルの重要性
3.2　アーキテクチャスタイルとしてのREST
3.3　リソース
リソースの名前としてのURI
リソースのアドレス可能性
複数のURIを持つリソース
リソースの表現と状態
3.4　スタイルを組み合わせてRESTを構成する
クライアント／サーバ
ステートレスサーバ
キャッシュ
統一インタフェース
階層化システム
コードオンデマンド
REST = ULCODC$SS
3.5　RESTの2つの側面
RESTとハイパーメディア
RESTと分散システム
3.6　RESTの意義
```

### RESTfulでないWeb APIとは？

先程説明のために例として取り上げた
「こういうURLにGETアクセスすると、こういうリストが得られる」
などは、実はいずれもRESTfulなAPI。
ではRESTfulでないAPIとは何か？

Web APIとは、所詮「HTTPというプロトコルを用いたAPI」に過ぎない。
だからRESTfulでないAPIも作れる。

一番わかりやすいのは、Cookieによるセッション管理。
Google Driveにアクセスすると、ログインしていない場合はサービス説明のような画面が現れる。
ログインすると、自分のファイルの一覧が見られる。
一度ブラウザを閉じてあとでもう一度見に行った場合、
「自分のアカウントでログインした」という情報は残っており、それを使って勝手にアクセスされる。
それがCookieという仕組みを用いたセッション管理。

このような仕組みを使ってAPIを作ることも可能。
※Google Drive自体はAPIではない（マウスなどを使って対話的に色々できるWebアプリケーションサービス）。

例：
http://example.com/myfiles にアクセスすると、ログインしていないのでエラーになる
http://example.com/login?id=taro&pass=??? というアドレスでログインする
そうすると、cookieに自分のIDでのログイン記録が残っていて、
http://example.com/myfiles で、自分のファイルのリストが得られる。
http://example.com/logout にアクセスするとログアウトできる
http://example.com/myfiles にアクセスすると、ログインしていないのでエラーになる

これでも、もしこれが明文化され公式にサポートされればWeb APIではある。
が、http://example.com/myfiles が返してくるデータが、ログイン前とログイン後で異なる。
これは、「ログインしているか」という状態の情報をURL以外にもっており、
サーバ側に保存されているためである。

では、taroさんがログインしたまま放置した場合、
これはずっとそのままになってしまうのか？とか。
状態をもつインタフェースの場合、状態を管理しないといけない。
サーバ側で状態を管理する場合、全ユーザの状態をサーバ側で管理しないといけない。

RESTかRESTでないのがいいかはやり方の問題なので、議論にはなったが、
RESTでないとこの状態の管理が大変なこと、
Amazonの商品のAPIなどが流行ったことなどが原因で、RESTが主流となった。

### RESTfulでないWeb APIとは？

  * メソッドとパス
  * ヘッダ
  * ボディ
  * ステータス


## HTTPの構成要素

```
noritada[9:00]%  curl -v http://ioc.wni.com/
*   Trying 172.16.20.63...
* TCP_NODELAY set
* Connected to ioc.wni.com (172.16.20.63) port 80 (#0)
> GET / HTTP/1.1
> Host: ioc.wni.com
> User-Agent: curl/7.54.0
> Accept: */*
>
< HTTP/1.1 200 OK
< Date: Fri, 08 Nov 2019 00:00:28 GMT
< Server: Apache/2.2.24 (FreeBSD) mod_ssl/2.2.24 OpenSSL/0.9.8x PHP/5.3.25 with Suhosin-Patch
< Accept-Ranges: bytes
< Content-Length: 24617
< Content-Type: text/html; charset=none
<

<?xml version="1.0" encoding="Shift_JIS"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
(snip)
```

http://ioc.wni.com/ に（ブラウザなどで）アクセスすると、

1. ioc.wni.comというサーバのIPアドレスをまず調べる
2. IPアドレスがわかったら、そのサーバのport 80につなぎにいく。
3. その上で`> `で始まる行の命令を送る（`GET / HTTP/1.1`など）（※`> `の各行先頭2文字は実際には送られない）
4. すると、サーバから`< `で始まる行のヘッダ（`HTTP/1.1 200 OK`など）とその下の本体（この場合はHTML）が返ってくる（※ヘッダの`< `の各行先頭2文字は実際には入らない）
5. あとはアプリケーション次第。ブラウザの場合は、HTMLを解析して、例えば`<img>`タグで画像を埋め込んでいたらその画像もGETしにいくし、JavaScriptのスクリプトファイルを別ファイルとして読み込んでいたらそれもGETしにいく。

詳しくは自分が書くよりも下記をおすすめします。

[『Webを支える技術 ── HTTP，URI，HTML，そしてREST』](https://gihyo.jp/magazine/wdpress/plus/978-4-7741-4204-3)、特に第7章
![](https://gihyo.jp/assets/images/cover/2010/9784774142043.jpg)

[『Real World HTTP ミニ版』](https://www.oreilly.co.jp/books/9784873118789/)
![](https://www.oreilly.co.jp/books/images/picture_large9784873118789.jpeg)


## curlを使ってHTTPを眺める
