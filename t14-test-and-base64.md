# 継続トレーニング #14：テストコードとBase64

## 概要

今回はテストコードについてお話します。
テストコードは、あれば品質が担保されるというものではありませんが、
一つの目安になりますし、何より、あれば他の人がコードを触りやすくなります。

また、コーディング規約とコード整形ツールについても軽く触れます。

実際にメインのコードと一緒にテストを書いていきますが、その際の題材としてはBase64を扱います。


### 本日お話すること

* テストコードとは
* テストコードがあると嬉しい理由
* テストコードを書く上での注意事項
* はじめてのテストコード
* Base64エンコード
* コーディング規約とコード整形ツール

## テストコードとは

何かを実現する、たとえば数百行くらいのプログラムを書いたときに、
そのようなプログラムが一発で、バグがまったくない状態で書けることはまずない。
「うまく動かない〜」などと言いながら、デバッグすることになる。

一番簡単なデバッグと修正は、`print()`しまくること。
`print()`の出力を見ながらコードをいじって、
うまく動くようになったら`print()`を消す。
というのは、多くの人が一番最初に通る道のはず。

でも、その「うまく動くようになった」というのはその人が確認しただけ。
ほかの人が確認したいこともある。

* 大きなソフトウェアで、色々な機能実装やバグ修正がきちんとできていることを、
  PMなどチームの他の人も確認したい。
* 特に、修正に漏れがないか
  （こういうケースでは動くけど、こういうケースではまだ動かない、など）
  などを他の人も確認したい。
* 後でプログラムに改変を加える必要が出てきたときに、
  改変を加えた後も元々の機能がきちんと動くことを確認したい。

そういったときに、テストコードがあるとよい。
テストコードは、「こういうときに、こういう結果になる」というのをプログラムに落としたもの。

* 関数`a`に1を渡したら2が返ってくる
* 関数`a`に-1を渡したら例外が発生する

## テストコードがあると嬉しい理由

* 品質の目安になる
  * ただしイコールではない。手動のテストであってもしっかりやられていることはある。
  * イコールではないが、「可視化」はされる。同時に、テスト不足の可能性も可視化される。
* メインのプログラムの理解につながる
  * 前回コードリーディングの際にお話したように、
    ドキュメントやテストなどは、ソースコード本体の理解のヒントになる。
* 後からプログラムに対する大きな変更を安全に加えやすい
  * 当初予定していなかった変更を加えているうちに汚くなったコードを、
    見通しよく、効率のよいものにするのを意図して書き換えることを「リファクタリング」という。
    それがやりやすい。
  * 他人のソースコードや巨大なソースコードを変更しても、品質が保証できる。

## テストコードを書く上での注意事項

### テストコードがあるからいいわけではない

「テストコードがあるからいい」というわけではない。
テストの設計がきちんとできていなかったら、たとえテストコードがあっても意味がない。
たとえば、入力が正の場合と負の場合で動作が異なるプログラムがあるとする。
入力が正のときのテストケースしか書かれていなかったら、
負のときはチェックされていないことになる。

テストの設計と、それをコードに落とす話は別の話。
テストの設計は、やるのが人間でも機械でもよいので、
「こういうケースを確認する」というのをきちんと設計する話。
テストコードを書くのは、それをいつでも再実行できるようにプログラムに落とす話。

### テストコードを書くにも時間がかかる

テストコードもプログラムなので、書くには時間がかかる。
そして、すべてのテストケースを網羅するのはかなり大変な作業。
どういうテストが重要か、あるいはどういうテストは人間の手でやると大変かを考えて、
そのようなテストのコード化を優先させたほうがよい。
時間は限られているので、場合によっては手動テストとの併用だったり、
リスクが少ない部分はテストしないという選択肢もありうる。

## テストフレームワーク

テストコードを書くには、テストフレームワークを使ったほうがよい。
テストフレームワークは、各言語でさまざまなライブラリとして提供されている。

代表的（？）なものはこんな感じ。

* Pythonの場合
  * unittest (言語標準)
  * pytest
* Perlの場合
  * Test::More
  * Test::MockObject
* Rubyの場合
  * test-unit (言語標準)
  * RSpec

ほかの言語にも「XXUnit」のようなライブラリがたいてい提供されている。
JavaのJUnitが一番有名。

上に「言語標準」と書いたとおり、最近の言語には、プログラミング言語本体についている。
ただ、標準ライブラリのものは、追加でライブラリをインストールしなくても使えるので楽なのだが、
使い勝手や機能などの観点でほかのものが好まれる場合もある。

Pythonの場合は、標準ライブラリとして含まれているunittestもあり、
ほかの言語のXXUnitと同じような書き方ができるのだが、
多くのしっかりしたプロジェクトではpytestのほうが好まれているようである。

### 豆知識

OS標準ライブラリは、その言語のサードパーティのライブラリに依存することができない。
Cのサードパーティのライブラリをwrapして、というようなことは可能だが、
依存関係が無駄に増えるのは通常は嫌がられる（その言語のプロジェクトの基本方針による）。
なので、便利な場合もあるし、そうでない場合もある。

## はじめてのテストコード

pytestのREADMEに書かれていたテストコードを引用。

```.py
# content of test_sample.py
def inc(x):
    return x + 1


def test_answer():
    assert inc(3) == 5
```

ここで、`inc()`は、動作を確認したいプログラムのイメージ。
それに対するプログラムが`test_answer()`。
これらが`test_sample.py`に含まれている。

pytestは、カレントディレクトリ以下の `test_*.py` と `*_test.py` をすべて見つけ出して、その中の`test`で始まる関数やメソッドを実行してくれる（詳しくは[ドキュメントの検出条件](https://docs.pytest.org/en/latest/goodpractices.html#test-discovery)を参照）。

実行結果（ターミナル幅に合わせた幅で表示されている。また、テキストではわからないがカラーリングされている）：

```
noritada[8:34]%  pytest
=========================================================================================== test session starts ============================================================================================
platform darwin -- Python 3.7.6, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /Users/noritada/gitwc/dit-training/t14/00
collected 1 item                                                                                                                                                                                           

test_sample.py F                                                                                                                                                                                     [100%]

================================================================================================= FAILURES =================================================================================================
_______________________________________________________________________________________________ test_answer ________________________________________________________________________________________________

    def test_answer():
>       assert inc(3) == 4
E       assert 5 == 4
E        +  where 5 = inc(3)

test_sample.py:7: AssertionError
============================================================================================ 1 failed in 0.04s =============================================================================================
```

期待している値（4）と実際の返り値（5）が異なるので、そのように知らせてくれている。

## 実用的（？）なテストコード

上の例では、メインのコードとテストを同じ`test_sample.py`というファイルに書いたが、
ふつうは分けて書きたい。
というよりも、
メインのコードは`test_sample.py`でなくもう少しまともな名前のファイルに入れたい。
そういう例は[こちら](t14/1/)。

この例では、`if __name__ == "__main__"`を利用して、
ライブラリとしてもスタンドアロンなプログラムとしても動くようになっている。

スタンドアロンなプログラムとしての実行：

```
noritada[9:10]%  python mod.py
12
```

テストフレームワークに、ライブラリとして読み込んでの実行：

```
noritada[9:10]%  pytest
=========================================================================================== test session starts ============================================================================================
platform darwin -- Python 3.7.6, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /Users/noritada/gitwc/dit-training/t14/1
collected 1 item                                                                                                                                                                                           

test_sample.py F                                                                                                                                                                                     [100%]

================================================================================================= FAILURES =================================================================================================
_______________________________________________________________________________________________ test_answer ________________________________________________________________________________________________

    def test_answer():
>       assert inc(3) == 4
E       assert 5 == 4
E        +  where 5 = inc(3)

test_sample.py:4: AssertionError
============================================================================================ 1 failed in 0.05s =============================================================================================
```

ここで注目してほしいのは、
`print`文は`if __name__ == "__main__"`の中に含まれているという点。

基本的に関数やメソッドの入力（）は引数、出力は返り値である。
printは「外の世界への作用」なので、
普通のやり方では`assert`でキャッチして何かと比較はできない。

画面に出力するテキストなどの値をテストしたい場合、
基本的にはこのように、関数では値として返した上で、
それを出力するのは他のところでやったほうがよい
（そちらのほうがプログラムとしてもスマートになる）。

## Base64とは

Base64とは、バイナリデータをテキストデータに変換するためのエンコード（符号化）方式である。
「バイナリなんて自分とは関係のない世界だ」と思うかもしれないが、
たとえばメールでPDFなどを添付ファイルとして送った場合、
添付ファイルはBase64でエンコードされて送られる。
場合によってはテキストメールでもエンコードされる。

アルゴリズムは[Wikipediaの説明](https://en.wikipedia.org/wiki/Base64)を参照するのがよい。
バイナリ6 bitsをASCII 1文字（8 bits）に変換して送る。
ASCIIの`A`–`Z`、`a`–`z`、`0`–`9`で62文字あるので、
それに記号2つ（`+`、`/`）とパディング用の`=`を加えた65文字が使われる。


## おまけ：コーディング規約とコード整形ツール

文法はあくまでプログラムがコードを理解するためのものだが、
命名規則とかスペースの空け方などについても取り決めたほうが、
人による好みが無駄な論争に繋がったり、
一々他人にどちらがよいか訊いたりしないで済む。
そのような規約をコーディング規約と言い、
Pythonでは[PEP 8](https://pep8-ja.readthedocs.io/ja/latest/)が一般的である。

色々な人がコードをいじると、
人によって書き方が違って、修正時に、本来意図した差分とは関係がない、
無駄な変更が入ってしまったりする。
基本的には、全員コミット前に[black](https://github.com/psf/black)を実行して、
コードを統一したほうがよい。
