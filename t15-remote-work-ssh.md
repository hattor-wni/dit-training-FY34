# 継続トレーニング #15：リモートワークを支える技術：SSH

## 概要

今回はリモートワークを支える技術としてSSHを扱います。

多くの人が「サーバに入ってコマンドを叩くためのもの」として知っており、
サーバを使い始めたときから使っていると思います。
そのため、ここでは基本的な使い方は最低限とし、
ほんの少し（ごくわずかですが）応用的な使い方を中心に扱います。

特に、新型コロナウイルスの影響でリモートワークが推奨されえいる昨今なので、
リモートワークで発生しそうなワークフローを中心に扱います。

なお、コマンドの説明をする珍しい機会でもあるので、
折角なので一般的な設定ファイルやオプションなどについても説明します。


### 本日お話すること

* SSHの基本
* 設定ファイルによる簡略化
  * 余談：なぜわざわざこんなに丁寧に基本的なことを書いたのか
  * 余談：設定項目やオプションの優先順位の決まり方
  * 余談：設定ファイルの場所と名前
* 公開鍵認証とパスワード認証
* 暗号鍵
* サーバ経由で別のサーバに入りたい：agent forwarding
* 社内Webツールの画面を見たい：port forwading
* セッションを維持したい：screenやtmux
* GUIを使いたい：X11
* リモートでのファイル編集
* ファイル転送：rsyncなど
* 「入れない！」と相談する前に
* おまけ：環境の違いと文字コード

## SSHの基本

SSHと言えば、まずは「サーバに入ってシェルを使うもの」。
次のような基本的な使い方は、ほとんどの人が経験しているはず。

基本形：

```
$ ssh noritada@172.16.57.110
Last login: Thu Mar 12 11:05:16 2020 from 172.16.xxx.xxx
>
```

「誰」として「どこ」のシステムに入って使うのか。
まずはこれ。
ここでは便宜上これを基本形としたい。

なお、`<ユーザ名>@`ではなく`-l <ユーザ名>`を好む人もいる。

ちなみに、「どこ」に加えて「どのドア（ポート）から」も重要だが、
SSHでは基本的にはウェルノウンポートの22番が割り当てられている
（ポートを変えるオプションもあるが、使うことはそんなにないように思う）。
この番号はHTTPの80番並みに（？）重要なので、覚えておいたほうがよい。

基本形を少し変えたバージョン：

```
$ ssh noritada@my-lovely-host
Last login: Thu Mar 12 11:05:16 2020 from 172.16.xxx.xxx
>
```

こういったホスト名でのアクセスは、名前解決により、
`my-lovely-host`というホスト名のIPアドレスを引いた上でログインしている。
`my-lovely-host`で名前が引けるのか、`my-lovely-host.wni.co.jp`としないといけないのか、
はネットワーク環境次第（たとえば社内なのかそうでないのか、など）。
IPアドレスでなくこのようにホスト名でアクセスすることのメリットは、当然「わかりやすさ」。

さらに変えたバージョン：

```
$ ssh my-lovely-host
Last login: Thu Mar 12 11:05:16 2020 from 172.16.xxx.xxx
>
```

ユーザ名が省略されている。つまり「どこに入る」のみのケース。
これは、ログイン元とログイン先のユーザ名が共通の場合。
つまり、
**ユーザ名を省略すると、元々のユーザ名と同じものを使って入ろうとしていると見なされる** 。
特に昔は、複数のホストがあって共通の管理者が管理しているのが普通だったので、
「どこに入る」だけで済んだ。

ただ、個々人がマシンをもつ時代になって久しい。
個々人がマシンをもつ場合、自分しか使わないマシンのユーザ名は自分が好きなようにつけたいし、
そのユーザ名は、管理者が全員を一意に識別するのに使うユーザ名と異なるのが普通とも言える。
だから、今の時代はユーザ名指定ありが普通なので、ここではあくまでそちらを基本形としている。

## 設定ファイルによる簡略化

いくらシェルのコマンドヒストリが使えるとは言え、
いつも同じような文字列を打つのはなるべく避けたいもの。

次のような設定を`~/.ssh/config`にすると、
たとえば、すべてのホストに`koba-n@`で入ってくれる。

```
Host *
  User koba-n
```

自分はこれで、
自分のプライベートマシンのユーザ名（`noritada`）と共同利用のサーバのユーザ名（`koba-n`）の違いを吸収している。

もちろん、コマンドラインで`nori@`と指定すればそのユーザ名が優先される。
要は、真面目に書くと、アクセスに使われるユーザ名はこう決まる：

1. コマンドラインでの指定があればそれを使う
2. 設定ファイルでの指定があればそれを使う
3. デフォルトは、アクセス元のユーザ名

こういうのは、
**感覚的にはわかると思うけど、こういう風にきちんと頭の中で整理しておくのが大切** 。
自分が何かカスタマイズ可能なプログラムを作るときには、整理されていなければ作れないので。

なお、上ではさらっと説明したが、この設定ファイルでは、
`*`という「ワイルドカード」を使って、すべてのホストに設定を適用するのを可能にしている。
要は、1文字の`*`は **グローバルな設定** である。

当然ながら、下記のようなかたちで、ホストごとに指定することも可能。

```
Host *
  User koba-n

Host aaa
  User koba

Host bbb
  User kbn
```

この場合、当然ながら個々のホストの設定がグローバルな設定に優先する。

設定ファイルによる設定は、ユーザ名以外についても可能である。

```
Host web
  User koba-n
  HostName very-long-long-host-name-for-web-server.wni.co.jp
  ConnectTimeout 60
```

この場合、たとえば、下記2つは同じ意味になる。

```
$ ssh web
```

```
$ ssh -o ConnectTimeout=60 koba-n@very-long-long-host-name-for-web-server.wni.co.jp
```

設定に関してもっと知りたい場合はmanpageを参照。

```
$ man ssh_config
```

ちなみに、`-v`オプションをつけてログインすれば、何の設定が適用されているか確認できる。

```
noritada[8:40]%  ssh -v hoge.wni.co.jp
OpenSSH_7.8p1, LibreSSL 2.6.2
debug1: Reading configuration data /Users/noritada/.ssh/config
debug1: Reading configuration data /Users/noritada/.ssh/config
debug1: /Users/noritada/.ssh/config line 1: Applying options for *
debug1: /Users/noritada/.ssh/config line 6: Applying options for hoge.wni.co.jp
debug1: Reading configuration data /etc/ssh/ssh_config
debug1: /etc/ssh/ssh_config line 48: Applying options for *
:
```

### 余談：なぜわざわざこんなに丁寧に基本的なことを書いたのか

世の中には、他の人が親切に設定してくれたりすることがある。
あるいは、よくわからないまま他の人が教えてくれたとおりに設定ファイルを書いた上で、
プログラムを使い続けているケースもある。
しかしそのようなものを使っていると、自分がどういう設定でコマンドを使っているかがわからない。
現に、自分が何というユーザでログインしているかわからない人もいる。
そういう場合、ちょっと応用的なことをやろうとすると色々とハマってしまう。
なので、以下の2点が大切。

1. まずは基本形を抑える
2. それをカスタマイズする方法として何があるのかを抑える

ちなみに、

* 現在のユーザ名を確認したい場合は`whoami`コマンドを使うこと
* 現在のホスト名を確認したい場合は`hostname`コマンドを使うこと

### 余談：設定項目やオプションの優先順位の決まり方

先程、`ssh`コマンドのオプションなどの決定に関する優先順位を簡単に説明した。
もう少し真面目に書くとこうなる。

1. コマンドラインでの実行時（ランタイム）の指定があればそれを使う
2. 個人の設定ファイル（`~/.ssh/config`）に、そのホストに関する指定があればそれを使う
3. 個人の設定ファイルに、グローバルな設定（`*`）があればそれを使う
4. システム共通の設定ファイル（たいていは`/etc/ssh/ssh_config`）に、そのホストに関する指定があればそれを使う
5. システム共通の設定ファイルに、グローバルな設定（`*`）があればそれを使う
6. 設定に記載がない場合は、ビルトインの挙動に従う（たとえば、ユーザ名としては、アクセス元のユーザ名を使う）

このような優先順位は、感覚的にも自然で直感的だと思う。
ほとんどのプログラムでは、同じような優先順位で動作が決まるようになっている。

1. 実行時（ランタイム）の指定
2. 個人の設定（特定対象）
3. 個人の設定（グローバル）
4. システム共通の設定（特定対象）
5. システム共通の設定（グローバル）
6. ビルトイン

自分でプログラムを書くときも参考にするとよい。

### 余談：設定ファイルの場所と名前

Unix全般ではたいてい以下が設定ファイルの置き場所となっている：

* 個人の設定ファイル：`~/`の下に、`.`を頭につけた名前で置かれる
* システム共通の設定ファイル：`/etc`、`/usr/local/etc`などの下に置かれる

また、名前はプログラム名をベースに、`rc`や`conf`などをつけたものがよく使われる。

## 公開鍵認証とパスワード認証

パスワード認証は、Webサービスなどでもよく使われているように、
事前にパスワードを設定しておいて、
ログイン時に入力したパスワードがそれと一致するかを確認する、という方式。
公開鍵認証は、予め公開鍵と秘密鍵のペア（鍵ペア）を作っておいて、それを用いて認証する方式。
一般的には公開鍵認証のほうが安全とされる。

パスワード認証では、認証時にパスワードを尋ねられ、ユーザはそれを入力する。
公開鍵認証では、認証時に秘密鍵のパスフレーズを求められ、ユーザはそれを入力する。
似ているようだが、二者は全然異なるし、用語も使い分けられている。
入力したパスワードはネットワークを経由して目的のホストに送られ、そこでチェックされる。
一方、入力したパスフレーズはローカルで秘密鍵を扱うのに使われ、ネットワークで転送されることはない。

原理などは、これを読むのがよいかと思う。

* [SSHの公開鍵認証における良くある誤解の話](https://qiita.com/angel_p_57/items/2e3f3f8661de32a0d432)

注意しなければいけないのは、秘密鍵の置き場所としては、
個人マシンなど、他人から見えないところでないといけないという点。
つまり、メールでサーバに持っていくなどはしてはいけない。

## 暗号鍵

暗号鍵で使えるアルゴリズムは、RSA、DSA、ECDSA、Ed25519など色々とある。
それぞれのアルゴリズムに興味があれば自分で調べよう。
強度は鍵のアルゴリズムによっても異なるし、
鍵の長さ（ビット数）にも依存する。
もちろん短いほうが弱いし、同じビット数でも、
時間が経ってコンピュータの計算力が上がれば脆弱になることがある。
「このアルゴリズムのこのビット数は脆弱になったのでサポートしなくなった」など、
OSのアップグレードで使えなくなることもあるので、そういうことがあると理解しておくこと。

RSA、DSA、ECDSA、Ed25519それぞれデフォルトのファイル名が次のようになっている。

```
~/.ssh/id_rsa
~/.ssh/id_dsa
~/.ssh/id_ecdsa
~/.ssh/id_ed25519
```

なお、これらは秘密鍵のほうで、
公開鍵はこれらに`.pub`というサフィックスがついたファイル名となる。

また、これらはあくまで「デフォルト」であり、「勝手に見つけてもらえるファイル名」に過ぎない。
自分で適当な名前をつけて自分自身しか知らない場所に鍵を置いておくことも可能。

「どの鍵を使って」を指定するには、次のように`-i`オプションを使う。

```
$ ssh -i ~/.path/to/my/secret/key my-lovely-host
```

デフォルトの鍵名を使っていると勝手に見つけてもらえるので、
「どの鍵でサーバに入っているか」は知らなくても使えてしまうが、
複数の鍵を持っていると混乱のもとである。
**複数の鍵を持っていてもよいが、何を使ってサーバに入っているかはきちんと認識しておくこと。**

## エージェントを使ったログイン

何度も同じホストに公開鍵認証で入るときに、
秘密鍵のパスフレーズを毎回求められ、入力するのは結構面倒くさい。
そういうときに便利なのがエージェントだ。

エージェントは、スパイのようなものを想像する人がいるかもしれないが、
ここでは「代理人」のほうの意味である。
システムに常駐してくれて、鍵を登録しておいてあげると、
ユーザの代理人として、必要なときに鍵を行使してくれる。
Unixだと、`ssh`コマンドと一緒に入っている`ssh-agent`、
WindowsであればPuttyに同包されているPageantを使うのが普通だ。

Unixの場合、基本的には下記コマンドで起動することになっているが、
macOSの場合、最初から起動しているはず。

```
$ eval `ssh-agent`
```

鍵の登録には、下記のように秘密鍵のファイルを指定して`ssh-add`を実行する。
秘密鍵のファイル名やパスが異なる場合は、適宜読み替えること。

```
$ ssh-add .ssh/id_rsa
```

## サーバ経由で別のサーバに入りたい：agent forwarding

社外からSSHゲートウェイを経て社内のサーバに入るなど、
あるホストを踏み台にしてほかのホストに入りたい場合がある。
ここでは、踏み台とするホストのことを「中継ホスト」、
最終的に入りたいサーバのことを「目的ホスト」と仮に呼ぶ。

目的ホストに入りたい場合に、こんなやり方を考えるかもしれない。

* 秘密鍵のファイルを中継ホストに持っていって、その秘密鍵を使って目的ホストにログイン
* 目的ホストをパスワード認証可能にしておき、
  中継ホストから目的ホストへのログインにはパスワード認証を使う

ただ、これらには問題がある。
1つ目のやり方が良くないのは、上で書いたとおり、秘密鍵は秘密にすべきだからだ。
特に、中継ホストという、他の人もたくさん入る場所に持っていく点がまずい。
2つ目のやり方はまだましだが、
せっかく鍵を生成したのにそれを使わずパスワードにしている点がもったいない。

ここで登場するのが、前述のエージェントを使ったagent forwardingだ。
文字通りだとエージェントを転送するように見えるが、
実際には、中継ホストから目的ホストへの接続時に、
裏でローカルのエージェントと通信して認証の処理を行う。

やり方は簡単で、

1. 使いたい鍵をエージェントに登録しておく（鍵を預けておく）
2. 中継ホストへのログイン時にエージェントを転送するようにする。
3. 中継ホストに入ったらふつうに目的ホストにログインする。

具体的にはこんな感じ。

1. `ssh-add ~/.ssh/id_rsa`などで預けられる
2. 中継ホストへの`ssh`に`-A`オプションをつける
3. 目的ホストへの`ssh`については特に変化なし

### 環境変数SSH_AUTH_SOCK

ここはちょっと高度な話。

Unixにおいて、`ssh-agent`常駐プロセスと`ssh`コマンドは、
UNIXドメインソケットというシステム内での通信（プロセス間通信）の仕組みを使ってやりとりする。
`ssh-agent`コマンドは、そのUNIXドメインソケットのパスをechoする文字列を吐き出す。
下記`eval`は、そのechoを実行し、
環境変数`SSH_AUTH_SOCK`にUNIXドメインソケットのパスを設定する。

```
$ eval `ssh-agent`
```

つまり、
今、どこのUNIXドメインソケットを使ってやりとりしているかは、
`SSH_AUTH_SOCK`を見ればわかる。

たとえばこれは、現在のローカル環境のUNIXドメインソケットの場所になる。

```
noritada[8:46]%  echo $SSH_AUTH_SOCK
/private/tmp/com.apple.launchd.LfLNLwsOxj/Listeners
```

で、SSHのagent forwardingのために中継サーバに`-A`つきでアクセスすると、
中継サーバで自動的にこの環境変数がつける。

```
>  echo $SSH_AUTH_SOCK 
/tmp/ssh-Sw8uG1bJFn/agent.7972
```

重要なのは、次の2点。

* このパスにあるUNIXドメインソケットを使うと`ssh-agent`と会話できる。
* その`ssh-agent`を使うと、自分の鍵を使って他のマシンにアクセスできる。

要は、同じホストに入っている人がそれを使うと、
自分の名前を名乗ってアクセスできるようになってしまう。

怖いことだが、そういうことをしているのだ、と知っておいたほうがよい。

* [An Illustrated Guide to SSH Agent Forwarding](http://www.unixwiz.net/techtips/ssh-agent-forwarding.html)
* [SSH Agent Hijacking](https://www.clockwork.com/news/2012/09/28/602/ssh_agent_hijacking/)


## 社内Webツールの画面を見たい：port forwarding

社内のサーバのコマンドラインであれば、`ssh`コマンドの通常の使い方で事足りる。
しかし、たとえば社内のWebアプリケーションの画面を見たい場合はそうは行かない。
こういうときに使えるのがport forwardingだ。

port forwardingは、中継サーバを通じて、
目的サーバの特定のポートをローカルのポートとして転送する仕組み。

* [SSHポートフォワード（トンネリング）を使って、遠隔地からLAN内のコンピュータにログインする](https://www.clear-code.com/blog/2014/9/12.html)

サンプルを見るのがわかりやすい：

```
$ ssh -fNL 18889:172.16.xxx.xxx:8889 hoge.wni.co.jp
```

これは、hoge.wni.co.jpへのSSH接続を使って、
172.16.xxx.xxx:8889へのアクセスをlocalhost:18889へのアクセスにするコマンド。

* https://wide.wni.com/user/Noritada%20KOBAYASHI%20(koba-n)/RemoteAccess
* https://wide.wni.com/user/Satoshi%20HIROSHIMA/RemoteWork
* https://wide.wni.com/user/Yuki%20SUGITA/SshRemoteAccessDesignPattern

## セッションを維持したい：screenやtmux

「SSH接続先で長い処理を走らせていたら、
途中で接続が切れてしまって、処理が途中で終わってしまった」。
ということは、たまにある。
ショックが大きい。

そのようなときに便利なのが、screenやtmux。
昔はscreenだったけど、最近はtmuxのほうが流行り。
細かい使い方は説明すると


## GUIを使いたい：X11
## リモートでのファイル編集
## ファイル転送：rsyncなど
## 「入れない！」と相談する前に
## おまけ：環境の違いと文字コード
