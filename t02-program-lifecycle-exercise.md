# プログラムのライフサイクル -- プロセス、デーモン、サーバ、クライアント、インジェクション攻撃 [演習]

## 準備：今回の教材を手に入れる

第1回と同じリポジトリ（ https://github.com/weathernews/dit-training-FY34 からクローンできるもの）を使っていく。
まだGitに不慣れな場合は、
[第1回の演習](t01-version-control-exercise.md)の説明を参考にしよう。

### クローン（リポジトリが手元にない場合）

第1回に参加しなかった場合などは、下記手順に従う。

1. リポジトリを手元にクローンしてくる

### リポジトリを最新状態にする（リポジトリが手元にある場合）

第1回に参加した場合は下記手順に従う。

#### まずはリポジトリをクリーンにしてmasterに移動

1. `git status`で、リポジトリが汚れている（＝作業中のファイルがある）かを確認
2. 汚れている場合は、`git stash`で退避（あとで`git stash pop`で元の状態に戻せる）
3. `git checkout master`でmasterブランチに移動

#### プロジェクトページのリポジトリから新しい変更を取得してマージ

自分用にフォークしたほう（https://github.com/<GitHubアカウント名>/<プロジェクト名>）
から最初にクローンした場合は、そちらに新しい変更が入っていないため、
プロジェクトページから新しい変更を取得するよう、
「リモートリポジトリ」の設定をしてあげる必要がある。

1. `git remote add upstream https://<GitHubアカウント名>@github.com/weathernews/dit-training-FY34.git` で、プロジェクトページのリポジトリをpull元として追加
2. `git pull upstream master`

### 作業用ブランチを作って移動

1. `git branch`で、存在するブランチと今いるブランチを確認（masterにいるはず）
2. `git checkout -b t02`で、t02というブランチを作ってそちらに移動（表面上は何も変わらない）
3. `git branch`で、あらためてブランチを確認（t02にいるはず）

### 作業ディレクトリを準備

あくまで、今回の教材をやって提出したときに被らないディレクトリ構造にしたいだけで、
特に意味はない。

1. `cd t02`
2. `mkdir <アカウント名>`（自分のディレクトリを作る）
3. `cp -pR t02-hosts.tmpl <アカウント名>/t02-hosts`
4. `cp -pR public_html.tmpl <アカウント名>/public_html`

作りたいディレクトリ構造（koba-nの場合）：

```
<root>
├── t01/                            # ディレクトリの中身は省略
└── t02/
    ├── t02-hosts.tmpl/             # ディレクトリの中身は省略
    ├── public_html.tmpl/           # ディレクトリの中身は省略
    └── koba-n/
        ├── t02-hosts/              # ←T
        │   ├── docker-compose.yml  # ←D
        │   :
        └── public_html/            # ←P
            ├── hoge.txt
            ├── exercise/           # ←E
            :
```

今後、今回の演習にては次のような意味とする。

* `t02-hosts`：上の絵でTと書かれたディレクトリのこと
* `docker-compose.yml`：上の絵でDと書かれたファイルのこと
* `public_html`：上の絵でPと書かれたディレクトリのこと
* 課題保存用ディレクトリ：上の絵でEと書かれたディレクトリのこと

### Dockerの構築手順書を個々人の環境に合わせて微修正

次のように、`docker-compose.yml` の内容を、自分の環境に合わせて修正する必要がある。

```
% diff -u ../../t02-hosts.tmpl/docker-compose.yml docker-compose.yml
--- ../../t02-hosts.tmpl/docker-compose.yml	2019-10-25 00:50:39.000000000 +0900
+++ docker-compose.yml	2019-10-25 00:43:19.000000000 +0900
@@ -3,6 +3,6 @@
   ports:
     - "10080:80"
   volumes:
-    - /path/to/public_html/usr/share/nginx/html:ro
+    - ~/gitwc/dit-training-FY34/t02/koba-n/public_html:/usr/share/nginx/html:ro
   command:
     nginx -g 'daemon off;'
```

### Docker環境を起動

1. `t02-hosts` にて、最初に説明した`docker-compose up --build -d`で起動
2. http://localhost:10080/hoge.txt にアクセスして、「hoge」と表示されたら成功


## 演習1：プロセスを眺めてみる

課題保存用ディレクトリに、`exercise1.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナルを3つ立ち上げ、並べて表示する
   （「ターミナル1」「ターミナル2」「ターミナル3」と今後呼ぶ）
2. それぞれのターミナルで、`host_a`にログインする
3. それぞれのターミナルで、`cd`でホームディレクトリに移動する
4. ターミナル1で`sleep 30`というコマンドを叩く
5. 4の直後にターミナル2で`./hello.py`というコマンドを叩く
6. 5の直後にターミナル3で`ps auxww`というコマンドを叩く
7. 6の直後にターミナル3で`ps auxwwf`というコマンドを叩く
8. 7の30秒後にターミナル3で`ps auxww`というコマンドをもう一度叩く

「ターミナル2」ではプログラムが動き続けていると思いますので、
`control + C`で止めてください。
これについては後ほど。

また、ターミナル1〜3はこの後も使うので閉じないでください。


## 演習2：シバンによる動作の違いを見てみる

課題保存用ディレクトリに、`exercise2.txt`などといった名前のファイルを作って、
以下のそれぞれの実行結果を貼り付け、わかったことを書きましょう。

1. ホームディレクトリに`hello`で始まるスクリプトがたくさんあるのを`ls`で確認する
2. それぞれのスクリプトを、`python3 foobar.py`のように実行してみる。
3. 2でうまくいった場合は、`ps auxww`で当該プロセスがどのように表示されるか見てみる
4. 2でエラーになった場合は、何が原因か考える
5. 2と同様に、それぞれのスクリプトを、`./foobar.py`のように実行してみる。
6. 5でうまくいった場合は、`ps auxww`で当該プロセスがどのように表示されるか見てみる
7. 5でエラーになった場合は、何が原因か考える


## 演習3：同じプログラムを複数実行してみる

課題保存用ディレクトリに、`exercise3.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`./hello.py`というコマンドを叩く
2. ターミナル2でも`./hello.py`というコマンドを叩く
3. ターミナル3で`ps auxww`により1と2のプロセス、特にPIDを確認

## 演習4：プロセスにシグナルを送ってみる

課題保存用ディレクトリに、`exercise4.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`./hello.py`というコマンドを叩く
2. ターミナル2でも`./hello.py`というコマンドを叩く
3. ターミナル3で`ps auxww`により1と2のプロセスを確認
4. ターミナル1で`control + C`を実行
5. ターミナル1のプロセスが終了したが、ターミナル2では動いたままであるのをターミナル3で確認
6. ターミナル3にて、ターミナル2で実行中のプロセスのPIDを確認
7. 6で調べたPIDをもとに、ターミナル3にて`kill <PID>`を実行する
8. ターミナル2のプロセスが終了したことを確認


## 演習5：プロセスをシグナルでサスペンドしてみる

課題保存用ディレクトリに、`exercise5.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`./hello.py`というコマンドを叩く
2. ターミナル3で`ps auxww`により1のプロセスを確認
3. ターミナル1で`control + Z`を実行
4. ターミナル3で`ps auxww`により1のプロセスがまだあることを確認
5. ターミナル1で`control + C`を実行
6. ターミナル3で`ps auxww`により1のプロセスがまだあることを確認
7. ターミナル1で`fg`を実行
8. ターミナル1で実行が再開したことを確認

サスペンドは、ターミナル上でコマンドの実行を中断したい（けど後でまた再開したい）ときに便利である。


## 演習6：プログラムを書き換えてみる

課題保存用ディレクトリに、`exercise6.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`./hello.py`というコマンドを叩く
2. ターミナル2で`sed -ie "s/Hello/HELLO/" hello.py`というコマンドを実行
3. ターミナル2で`hello.py`の中の`Hello`が`HELLO`になったのを確認
4. ターミナル1の出力する文字列に変化がないことを確認
5. ターミナル2で`./hello.py`というコマンドを叩く
6. ターミナル2の出力する文字列は大文字になっているのを確認
