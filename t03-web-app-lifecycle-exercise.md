# 継続トレーニング #3：Webアプリケーションのライフサイクル -- 動的コンテンツと静的コンテンツ、CGI、Webアプリケーションサーバ、インジェクション攻撃 [演習]

## 準備：今回の教材を手に入れる

第1回と同じリポジトリ（ https://github.com/weathernews/dit-training-FY34 から最新の変更を取り込む。

1. 変更を一時的に退避し、masterブランチに移動
2. masterブランチにupstreamから変更を取り込む
3. masterから適当なブランチ（t03-workなど）を作り、移動
4. t03ディレクトリに移動
5. `./setup.sh <アカウント名>` で、自分用のディレクトリを作成（前回行っていただいたようなファイルのコピーを自動化するためのスクリプト）
6. `t03-hosts` にて、最初に説明した`docker-compose up --build -d`で起動

（Gitに関して、
コマンドからでなくVSCodeなど自分の環境からのほうが楽にバージョン管理の操作ができる場合は、
それでもOKです（フォローはできませんが……）。）

参考：

* [第1回の演習](t01-version-control-exercise.md)
* [第2回](t02-program-lifecycle.md) のdocker-composeの説明
* [第2回の演習](t02-program-lifecycle-exercise.md)

作られているディレクトリ構造（koba-nの場合）：

```
<root>
├── t03/
:   ├── t03-hosts.tmpl/             # ディレクトリの中身は省略
    └── koba-n/                     # ←E
        └── t03-hosts/              # ←T
            ├── docker-compose.yml
            :
```
（前回は複雑だったので、シンプルにしました。）

今後、今回の演習にては次のような意味とする。

* `t03-hosts`：上の絵でTと書かれたディレクトリのこと
* 課題保存用ディレクトリ：上の絵でEと書かれたディレクトリのこと

### Docker「マシン」の一覧：

Dockerを使っている関係で、すべて http://localhost:xxxxx/ というかたちになってしまい、
見ているものがわかりにくいかもしれません。
この演習では、下記のように対応しています。

| URL | 本来のURL | 人間向けの説明 | 登場する演習 |
|-|-|-|-|
| http://localhost:10081/ | http://cgi/ | cgiというホストのWebサーバへのアクセスのためのURL | 演習1、2 |
| http://localhost:10082/ | http://webapp/ | webappというホストのWebサーバへのアクセスのためのURL | 演習3 |
| http://localhost:10083/ | http://webapp-threaded/ | webapp-threadedというホストのWebサーバへのアクセスのためのURL | 演習4 |
| http://localhost:10084/ | http://wildcard/ | wildcardというホストのWebサーバへのアクセスのためのURL | 演習5 |
| http://localhost:10085/ | http://api/ | apiというホストのWebサーバへのアクセスのためのURL | 演習6 |

（設定は `t03-hosts/docker-compose.yml` でなされています！）


## 演習1：WebサーバでCGIを動かしてブラウザの表示とプロセスを確認してみる

課題保存用ディレクトリに、`exercise1.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナルを3つ立ち上げ、並べて表示する
   （「ターミナル1」「ターミナル2」「ターミナル3」と今後呼ぶ）
2. ターミナル1で`cgi`というマシンにログインする
3. ターミナル1でプロセスを確認
4. ブラウザで http://localhost:10081/app.py にアクセスしてみる。10秒くらい待たないと表示されないはず。
5. ターミナル2とターミナル3で、ほぼ同時に `curl -v http://localhost:10081/app.py` を実行
6. 5の直後にターミナル1でプロセスを確認
7. 5の結果が帰ってきたら、ターミナル1で再度プロセスを確認

注意：

* プロセスの確認には、`f`をつけて`ps auxwwf`としてあげてください。

着眼してほしい点：

* curlからのアクセスにより増えたプロセスは、どのプロセスを親としているか？
* httpdのプロセスとしては、rootのものが1つとdaemonユーザのものがいくつかあること


## 演習2：WebサーバでコマンドラインからCGIのプログラムを実行してみる

課題保存用ディレクトリに、`exercise2.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル2で`cgi`というマシンにログインする
2. `./app.py` というコマンドを叩いてみる。10秒くらい待たないと表示されないはず。
3. ターミナル1（`cgi`にログインしたまま）でプロセスを確認

着眼してほしい点：

* app.pyのプロセスは、どのプロセスを親としているか？
* app.pyのプロセスが演習1と異なるのは何故か？


## 演習3：Webアプリケーションサーバを動かしてブラウザの表示とプロセスを確認してみる（シングルスレッド）

課題保存用ディレクトリに、`exercise3.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`webapp`というマシンにログインする
2. ターミナル1でプロセスを確認
3. ブラウザで http://localhost:10082/sleepy にアクセスしてみる。10秒くらい待たないと表示されないはず。
4. ターミナル2とターミナル3で、ほぼ同時に `curl -v http://localhost:10082/sleepy` を実行
5. 4の直後にターミナル1でプロセスを確認
6. 4の結果が帰ってきたら、ターミナル1で再度プロセスを確認

注意：

* curlコマンドは、ブラウザと同様、URLにHTTPアクセスするコマンドです。
  次回のHTTP講座にてやります。

着眼してほしい点：

* ターミナル2とターミナル3のcurlコマンドの実行タイミングはほぼ同じか？大きく異なるか？
* ブラウザに表示されるページ（`curl`コマンドの出力内容）に、
  実行開始直後の時刻と実行終了直前の時刻が出力されているが、
  それらはどのようになっているか？
  一方の処理が終わってからもう一方の処理が行われていないか？
* CGIの場合と異なり、アクセスがない場合（2）とアクセスされてレスポンスのための計算をしているとき（5）でプロセスに変化がないはず。


## 演習4：Webアプリケーションサーバを動かしてブラウザの表示とプロセスを確認してみる（マルチスレッド）

課題保存用ディレクトリに、`exercise4.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ターミナル1で`webapp-threaded`というマシンにログインする
2. ターミナル1でプロセスを確認
3. ブラウザで http://localhost:10083/sleepy にアクセスしてみる。10秒くらい待たないと表示されないはず。
4. ターミナル2とターミナル3で、ほぼ同時に `curl -v http://localhost:10083/sleepy` を実行
5. 4の直後にターミナル1でプロセスを確認
6. 4の結果が帰ってきたら、ターミナル1で再度プロセスを確認

着眼してほしい点：

* ターミナル2とターミナル3のcurlコマンドの実行タイミングはほぼ同じか？大きく異なるか？
* ブラウザに表示されるページ（`curl`コマンドの出力内容）に、
  実行開始直後の時刻と実行終了直前の時刻が出力されているが、
  それらはどのようになっているか？
* CGIの場合と異なり、アクセスがない場合（2）とアクセスされてレスポンスのための計算をしているとき（5）でプロセスに変化がないはず。


## 演習5：不正な文字列の埋め込み

課題保存用ディレクトリに、`exercise5.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

1. ブラウザで http://localhost:10084/?field=firstname&username=taro にアクセスしてみる。
2. ブラウザで http://localhost:10084/?field=*&username=taro にアクセスしてみる。

着眼してほしい点：

* 1つ目のコマンドは想定していた入力で、2つ目のコマンドは想定していなかった入力である。
  これは、ユーザからの入力を直接SQL文に埋め込んでいるために生じる。
  期待していない入力は受け付けないよう、ユーザからの入力は必ずチェックしないといけない。


## 演習6：「世界最悪のログイン処理コード」を支える技術

課題保存用ディレクトリに、`exercise6.txt`などといった名前のファイルを作って、
以下の実行結果を貼り付けましょう。

```
curl -X POST --data-urlencode sql='SELECT * FROM users' http://localhost:10085/
```

「世界最悪のログイン処理コード」は同じことをブラウザ上で行い、
ユーザ名とパスワードを照合してログインしています。
何が問題か、考えてみましょう。

ヒント：

* このHTTPリクエストは、JavaScriptを読んでやってみたものです。
  たとえこのデータがブラウザで表示されていなくても、
  JavaScriptを読める人は誰でもこのHTTPリクエストを思いつきます。
* `SELECT * FROM users`というのは、
  「データベース内の`users`というテーブルから、
  すべての行 × すべての列の情報（要はすべての情報）を抜き出してくる」
  という意味のSQL文です。
