# 継続トレーニング #10：エンジニア生活の送り方

## 概要

新年ということで、RMD Messageにおいても稼ぎと仕事の話や
「新年くらいはダチョウにならずワシの視点で」といった話がありましたが、
今回は、技術的な細かい各論の話をする平常運転からは少し趣向を変えます。

エンジニアとしての日々の過ごし方に関する指針、
どうエンジニアとして成長していくかを考えながら、
参加者の皆さんの実務や今後身につけたいことをもとに
今後の進め方やテーマを検討するコミュニケーションに
時間を費やす場にします。

### 本日お話すること
* エンジニア生活の送り方に関する書籍の紹介
* 議論


## エンジニア生活の送り方に関する書籍の紹介

* 普段、どういう考え方で過ごすべきか？
* 成長したい場合にどうしたらよいか？

に関して、エンジニア生活の送り方に関する書籍を紹介しておきます。
内容は、目次などを見ればだいたいわかるはずなので、
この後で引用しておきます。

なお、以下はあくまでそれぞれの著者の考え方を示したものなので、
自分に適用するかどうかは自分の頭で考えること。

少なくともWNIでは、
エンジニアリングだけをしている人はそんなに多くないし、
いくら見つけたバグは直すべきであっても、
納期が限られているときに、本来やるべきことをそっちのけで小さな問題の対応などをしたら、
おそらく問題に成るでしょう。

また、DRY原則は重要ではありますが、
言語によっては厳しい場合もありますし、
必要以上にそこに注力しても読みにくくなる場合もあります。
なので、考え方を学ぶのが重要です。

* [ベタープログラマ ――優れたプログラマになるための38の考え方とテクニック](https://www.oreilly.co.jp/books/9784873118208/)
    * 2017年12月14日発行
    * エンジニア生活全般で最近の書籍ならこれ。
* [エンジニアの知的生産術 ──効率的に学び，整理し，アウトプットする](https://gihyo.jp/magazine/wdpress/plus/978-4-7741-9876-7)
    * 2018年8月10日発行
* [情熱プログラマー ソフトウェア開発者の幸せな生き方](https://shop.ohmsha.co.jp/shopdetail/000000001848/)
    * 2010年2月25日発行
* [新装版 達人プログラマー 職人から名匠への道](https://shop.ohmsha.co.jp/shopdetail/000000004729/)
    * 2016年10月25日発行（原書は1999年、ピアソンエデュケーション版の訳書は2000年）
    * エンジニア生活全般に関する名著。ただ古く、今の開発環境などにそぐわない部分もあるので、その点を踏まえる視点は必要かも。

### ベタープログラマ
#### 目次より

* 1章　コードを気にかける
    * コードへの正しい取り組み方と態度を身に付ける
* 第Ⅰ部　you.write(code)
    * 2章　見かけのよい状態を維持する
        * コードの表現：レイアウトと名前付け
    * 3章　少ないコードを書く
        * 不必要なコードを書かない
    * 4章　取り除くことでコードを改善する
        * 死んでいるコードを見つけて取り除く
    * 5章　コードベースの過去の幽霊
        * 過去に書いたコードから学ぶ
    * 6章　航路を航行する
        * なじみのないコードへの取り組み方
    * 7章　汚物の中で転げ回る
        * 不快でひどいコードを取り扱う
    * 8章　そのエラーを無視するな！
        * エラー処理に対する健全な態度
    * 9章　予期せぬことを予期する
        * あらゆる可能性を考慮して、頑強なコードを書く
    * 10章　バグ狩り
        * バグを見つけて修正する
    * 11章　テストの時代
        * 開発者テスト：単体テスト、インテグレーションテスト、システムテスト
    * 12章　複雑さに対処する
        * 不必要な複雑さを避けるために、コードをうまく設計する
    * 13章　二つのシステムの物語
        * 優れた設計とひどい設計の顛末
* 第Ⅱ部　練習することで完璧になる
    * 14章　ソフトウェア開発とは
        * ソフトウェア開発とは何か
    * 15章　規則に従って競技する
        * 開発チームの役割を明確にする規則を作る
    * 16章　単純に保つ
        * ソフトウェアの簡潔性を追い求める
    * 17章　頭を使いなさい
        * プログラマは頭を使うことができるし、そうするべきである
    * 18章　変わらないものはない
        * コードは不可侵ではなく変化する
    * 19章　コードを再利用するケース
        * コードを再利用するための健全な方法
    * 20章　効果的なバージョンコントロール
        * バージョンコントロールをうまく使う
    * 21章　ゴールポストを抜ける
        * QAチームと協業する
    * 22章　凍結されたコードの数奇な人生
        * コード凍結とは何か。そもそも必要か
    * 23章　プリーズ・リリース・ミー
        * ソフトウェアリリースを作成する
* 第Ⅲ部　個人的なこと
    * 24章　学びを愛して生きる
        * 効果的な学び方
    * 25章　試験に基づく開発者
        * プログラミングと自動車運転の類似：どのように学び、どのように試験に合格するか
    * 26章　チャレンジを楽しむ
        * モチベーションを維持し、スキルを高く維持するための課題の見つけ方
    * 27章　停滞を避ける
        * プログラミングスキルの陳腐化を防ぐ
    * 28章　倫理的なプログラマ
        * 開発者人生における倫理的な問題
    * 29章　言語への愛
        * 多くのプログラミング言語を学び、使っている言語を愛する
    * 30章　プログラマの姿勢
        * プログラマの健康の改善：姿勢、目の疲労、元気の維持
* 第Ⅳ部　成し遂げる
    * 31章　一生懸命ではなく、賢く
        * 効果的に働く：不要な作業を回避して、問題を解決する
    * 32章　完了したときが完了
        * プログラミングのタスクを明確にし、終わったときを正確に把握する
    * 33章　今度こそ分かった……
        * 視野を狭くしない：問題を解決する最善な方法を見つける
* 第Ｖ部　人々の営み
    * 34章　人々の力
        * 優れたプログラマと一緒に働く。チームでうまく働く方法
    * 35章　原因は思考
        * 説明責任：自分自身と自らの働きを向上させる
    * 36章　遠慮なく話す
        * ソフトウェア開発者にとってのコミュニケーションスキル
    * 37章　多くのマニフェスト
        * ソフトウェアのマニフェストとは何か。なぜ必要か
    * 38章　コードへの叙情歌
        * 間違ったソフトウェア管理の教訓

### エンジニアの知的生産術
#### 目次より

* 第1章：新しいことを学ぶには
    * 学びのサイクル
        * 情報収集
        * モデル化・抽象化
        * 実践・検証
    * サイクルを回す原動力：やる気
        * 生徒としての学びと大学からの学びの違い
            * 教科書が与えられる
            * 学ぶ時間はどれくらいあるか？
            * 学ぶお金は誰が出すのか？
            * 逆風
        * やる気を維持するには？
            * ゴールは明確に
            * チュートリアルはゴールを近くする
            * ［Column］SMART criteria
        * 大学に入りなおすべき？
            * もっと気軽な方法
        * 良い参考書を見つけるコツ
        * 紙の参考書を選ぶコツ
            * 大学の講義の参考図書に選定されている
            * 正誤表が充実している
            * 改訂されている・ロングセラーである
    * 情報収集の3つの方法
        * 知りたいところから
            * 遅延評価的勉強法
            * 「そんなの必要ないよ」YAGNI原則
            * Matzのソースコードの読み方
        * 知りたいところから学ぶための前提条件
            * 目標が明確化されている
            * 目標が達成可能である
            * 大まかに全体像を把握している
        * 大雑把に
            * ［Column］見つける力は10年後も必要か？
            * 1,000ページ以上ある資料も，目次はたった6ページ
            * ソースコードを段階的に読む
            * ドキュメントの大まかな構造
            * 英語の論文の大まかな構造
            * 民法の地図
            * ［Column］民法マップの抜粋
        * 片っ端から
            * 写経というテクニック
            * 数学
            * 時間を区切ろう
            * 写経は補助輪
            * 再び写経を必要とするとき
    * 抽象とは何か
        * 抽象・abstract
        * モデル・模型
        * モジュール
            * 相互作用を制限する
            * 重要でない部分を隠す＝重要な部分を抜き出す
        * モデル・ビュー・コントローラ
        * パターンの発見
        * デザインパターン
            * ［Column］パターンに名前を付けること
        * なぜ抽象化が必要か？
            * パターンの発見による一般化
    * どうやって抽象化するか
        * 比較して学ぶ
            * 「同じ」と「違う」の間に注目
            * たとえ話
            * 違いに注目
        * 歴史から学ぶ
        * パターン本から学ぶ
    * 検証
        * 作って検証
            * 解説も作ることの一種
        * 試験で検証
        * 検証の難しい分野
    * まとめ
* 第2章：やる気を出すには
    * やる気が出ない人の65％はタスクを1つに絞れていない
        * 絞るためにまず全体像を把握しよう
        * Getting Things Done：まずすべて集める
        * 全部集めて，そのあとで処理をする
        * どうやってタスクを1つ選ぶのか
            * 部屋の片付けと似ている
            * まず基地を作る
            * タスクが多すぎる
    * 「優先順位付け」はそれ自体が難しいタスク
        * 並べることの大変さ
            * ［Column］緊急性分解理論
        * 1次元でないと大小比較ができない
        * 不確定要素がある場合の大小関係は？
            * 探索と利用のトレードオフ
            * 不確かなときは楽観的に
            * リスクと価値と優先順位
        * 重要事項を優先する
            * 「通知された」は「緊急」ではない
            * 価値観はボトムアップに言語化する
            * ［Column］7つの習慣
        * 優先順位を今決めようとしなくてよい
    * １つのタスクのやる気を出す
        * タスクが大きすぎる
            * 執筆という大きなタスク
        * タイムボックス
            * 集中力の限界
            * ポモドーロテクニック
            * 見積り能力を鍛える
            * 分単位で見積もるタスクシュート時間術
            * ［Column］PDCAサイクル
            * 計測し，退け，まとめる
    * まとめ
* 第3章：記憶を鍛えるには
    * 記憶のしくみ
        * 海馬
        * 海馬を取り除かれた人
        * Morrisの水迷路
        * 記憶は1種類ではない
    * 記憶と筋肉の共通点
        * 信号を伝えるシナプス
        * シナプスの長期増強
        * まず消えやすい方法で作り，徐々に長持ちする方法に変える
    * 繰り返し使うことによって強くなる
        * ［Column］海馬では時間が圧縮される
    * アウトプットが記憶を鍛える
        * テストは記憶の手段
        * テストをしてからさらに学ぶ
        * 自信はないが成績は高い
        * 適応的ブースティング
        * テストの高速サイクル
    * 知識を長持ちさせる間隔反復法
        * 忘れてから復習する
        * ライトナーシステム
        * 問題のやさしさ
        * 知識を構造化する20のルール
        * Anki
        * 難易度の自動調節
        * 教材は自分で作る
            * ［Column］知識を構造化する残り15のルール
            * 作る過程で理解が深まる
            * 個人的な情報を利用できる
            * 著作権と私的使用のための複製
    * まとめ
* 第4章：効率的に読むには
    * 「読む」とは何か？
        * 本を読むことの目的
            * 娯楽はスコープ外
            * 情報を得ることが目的か？
            * 情報伝達の歴史
            * 一次元の情報を脳内で組み立てる
            * 本の内容だけが理解を組み立てる材料ではない
            * 「見つける」と「組み立てる」のグラデーション
        * 「読む」の種類と速度
    * あなたの普段の読む速度は？
        * 読む速度のピラミッド
        * ボトルネックはどこ？
        * 速読の苦しみ
            * 続けられるペースを把握する
        * 読まない
            * 読まずに知識を手に入れる
    * １ページ２秒以下の「見つける」読み方
        * Whole Mind System
            * ❶準備
            * ❷プレビュー
            * ❸フォトリーディング
            * ❹質問を作る
            * ❺熟成させる
            * ❻答えを探す
            * ❼マインドマップを作る
            * ❽高速リーディング
            * 5日間トレーニング
        * フォーカス・リーディング
            * 速度を計測しコントロールする
        * 見出しなどへの注目
            * ［Column］時間軸方向の読み方
    * 1ページ3分以上の「組み立てる」読み方
        * 哲学書の読み方
            * 開いている本・閉じている本
            * 外部参照が必要な本
            * 登山型の本とハイキング型の本
        * 1冊に40時間かけて読む
            * 棚を見る
            * 読書ノートに書きながら読む
            * わからないことを解消するために読む
        * 数学書の読み方
            * わかるの定義
            * わかることは必要か？
    * 読むというタスクの設計
        * 理解は不確実タスク
        * 読書は手段，目的は別
            * 大雑把な地図の入手
            * 結合を起こす
            * 思考の道具を手に入れる
        * 復習のための教材を作る
            * レバレッジメモを作る
            * Incremental Reading
            * 人に教える
    * まとめ
* 第5章：考えをまとめるには
    * 情報が多すぎる？ 少なすぎる？
        * 書き出し法で情報量を確認
            * 質を求めてはいけない
            * 実践してみよう
            * 100枚を目標にしよう
            * 100枚目標のメリット
            * 重複は気にしない
    * 多すぎる情報をどうまとめるか
        * 並べて一覧性を高くする
            * ［Column］書き出し法の実例
        * 並べる過程で思い付いたらすぐ記録
        * 関係のありそうなものを近くに移動
            * ［Column］ふせんのサイズ
            * KJ法の流れ
        * グループ編成には発想の転換が必要
            * グループ編成は客観的ではない
            * グループ編成は階層的分類ではない
            * 既存の分類基準を使うデメリット
            * ［Column］フレームワークによる効率化
            * 事前に分類基準を作るデメリット
            * 分類で負担を減らすメリット
        * 関係とは何だろう
            * 類似だけが関係ではない
            * NM法は対立関係に着目する
            * 話題がつながる関係
        * 束ねて表札を付け，圧縮していく
            * 表札作りのメリット・デメリット
            * 表札を作れるグループが良いグループ
            * ふせんが膨大なときの表札作り
            * 「考えがまとまらない」と「部屋が片付かない」は似ている
            * ［Column］表札とふせんの色
            * ［Column］知識の整合性
        * 束ねたふせんをまた広げる
        * 文章化してアウトプット
    * 社会人向けチューニング
        * ステップの省略
        * 中断可能な設計
        * A4書類の整理法
    * 繰り返していくことが大事
        * KJ法を繰り返す
        * 繰り返しのトリガ
        * インクリメンタルな改善
        * 過去の出力を再度グループ編成
        * 電子化
    * まとめ
* 第6章：アイデアを思い付くには
    * 「アイデアを思い付く」はあいまいで大きなタスク
        * アイデアを思い付く3つのフェーズ
            * 耕すフェーズ
            * 芽生えるフェーズ
            * 育てるフェーズ
        * 先人の発想法
            * Youngのアイデアの作り方
            * 川喜田二郎の発想法
            * Otto Scharmerの変化のパターン
            * 芽生えは管理できない
    * まずは情報を収集する
        * 自分の中の探検
        * 言語化を促す方法
            * 質問によるトリガ
            * フレームワークのメリットとデメリット
            * 創造は主観的
        * 身体感覚
            * 絵に描いてみる
        * たとえ話・メタファ・アナロジー
            * NM法とアナロジー
            * Clean LanguageとSymbolic Modelling
        * まだ言葉になっていないもの
            * 暗黙知：解決に近付いている感覚
            * ［Column］二種類の暗黙知
            * 違和感は重要な兆候
            * Thinking At the Edge：まだ言葉にならないところ
            * 辞書との照合
            * 公共の言葉と私的な言葉
            * KJ法も違和感に注目
        * 言語化のまとめ
    * 磨き上げる
        * 最小限の実現可能な製品
            * 誰が顧客かわからなければ，何が品質かもわからない
            * 何を検証すべきかは目的によって異なる
        * U曲線を登る
        * 他人の視点が大事
        * 誰からでも学ぶことができる
        * タイムマシンを作れ
            * ［Column］知識の分布図
        * 再び耕す
            * ［Column］書籍とは双方向のコミュニケーションができない
    * まとめ
* 第7章：何を学ぶかを決めるには
    * 何を学ぶのが正しいか？
        * 数学の正しさ
        * 科学と数学の正しさの違い
        * 意思決定の正しさ
            * 繰り返す科学実験と一回性の意思決定
            * 事後的に決まる有用性
            * 過去を振り返って点をつなぐ
    * 自分経営戦略
        * 学びたい対象を探す探索戦略
            * ［Column］選択肢の数が意思決定の質にもたらす影響
            * 探索範囲を広くする
        * 知識を利用して拡大再生産戦略
        * 卓越を目指す差別化戦略
            * 他人からの知識の獲得はコストが安い
            * 他人から得た知識は価値が低い
            * 卓越性の追求
        * かけ合わせによる差別化戦略
            * ふたこぶの知識
            * 連続スペシャリスト
            * 新入社員の戦略案
        * 組織の境界をまたぐ知識の貿易商戦略
    * 知識を創造する

### 情熱プログラマー
#### 目次より

* 第1章 市場を選ぶ
    * 1 先んずるか、やられるか
    * 2 需要と供給
    * 3 コーディングはもう武器にならない
    * 4 一番の下手くそでいよう
    * 5 自分の知性に投資しよう
    * 6 親の言うことを聞くな
    * 7 万能選手になろう
    * 8 スペシャリストになろう
    * 9 自分の人生を他人任せにするな
    * 10 愛せよ、さもなくば捨てよ
* 第2章 製品に投資する
    * 11 魚の釣り方を学ぶ
    * 12 ビジネスの仕組みを学ぶ
    * 13 師匠を探す
    * 14 師匠になる
    * 15 一に練習、二に練習
    * 16 プロセスを大切にする
    * 17 巨人の肩の上で
    * 18 自動化によって仕事を確保する
* 第3章 実行に移す
    * 19 今すぐに
    * 20 読心術
    * 21 デイリーヒット
    * 22 誰のために働いているのか思い出す
    * 23 今の職務を全力で
    * 24 今日どれだけうまく仕事ができるか？
    * 25 自分にどれだけの価値があるか？
    * 26 バケツ一杯の水の中の小石ひとつ
    * 27 保守作業の真価を知る
    * 28 8時間燃焼
    * 29 失敗する方法を学ぶ
    * 30 できないことは「できない」とはっきり言う
    * 31 あわてるな
    * 32 言って、成して、示す
* 第4章 マーケティングスーツ族だけのものじゃない
    * 33 視点が違えば認識も異なる
    * 34 アドベンチャーツアーガイド
    * 35 オレ、作文的なのは得意っすよ
    * 36 そこに居ること
    * 37 スーツ語
    * 38 世界を変えよう
    * 39 業界で名前を売ろう
    * 40 自分のブランドを築こう
    * 41 自作のコードをリリースしよう
    * 42 目立つこと
    * 43 コネを作る
* 第5章 研鑽を怠らない
    * 44 既に時代遅れである
    * 45 君は既に職を失っている
    * 46 終わりのない道
    * 47 自分のロードマップを作る
    * 48 市場に気を配る
    * 49 鏡の中の太った男
    * 50 南インドのサル捕獲トラップ
    * 51 ウォーターフォール式のキャリア計画はやめよう
    * 52 昨日よりよく
    * 53 独立する
* 楽しもう

### 達人プログラマー
#### 目次より

* 第1章　達人の哲学
    * 1 猫がソースコードを食べちゃった
    * 2 ソフトウェアのエントロピー
    * 3 石のスープと蛙の煮物
    * 4 十分によいソフトウェア
    * 5 あなたの知識ポートフォリオ
    * 6 伝達しよう！
* 第2章　達人のアプローチ
    * 7 二重化の過ち
    * 8 直交性
    * 9 可逆性
    * 10 曳光弾
    * 11 プロトタイプとポストイット
    * 12 専用の言語
    * 13 見積もり
* 第3章　基本的なツール
    * 14 プレインテキストの威力
    * 15 貝殻（シェル）遊び
    * 16 パワーエディット
    * 17 ソースコード管理
    * 18 デバッグ
    * 19 テキスト操作
    * 20 コードジェネレータ
* 第4章　妄想の達人
    * 21 契約による設計
    * 22 死んだプログラムは嘘をつかない
    * 23 表明プログラミング
    * 24 いつ例外を使用するか
    * 25 リソースのバランス方法
* 第5章　柳に雪折れ無し
    * 26 結合度の最小化とデメテルの法則
    * 27 メタプログラミング
    * 28 時間的な結合
    * 29 単なる見かけ（ビュー）
    * 30 ホワイトボード
* 第6章　コーディング段階
    * 31 偶発的プログラミング
    * 32 アルゴリズムのスピード
    * 33 リファクタリング
    * 34 テストしやすいコード
    * 35 邪悪な魔法使い（ウィザード）
* 第7章　プロジェクトを始める前に
    * 36 要求の落とし穴
    * 37 不可能なパズルを解く
    * 38 準備ができるまでは
    * 39 仕様の罠
    * 40 丸と矢印
* 第8章　達人のプロジェクト
    * 41 達人チーム
    * 42 どこでも自動化
    * 43 容赦ないテスト
    * 44 すべてはドキュメント
    * 45 大きな期待
    * 46 誇りと愛着

#### 「付録C クイックリファレンスガイド」のTipより

* 自らの技術に関心を持つこと
    * 技術に関心を持たずに、どうやってソフトウェアの開発ができるのか？
* あなたの仕事について考えること！
    * 漫然と仕事するのではなく、意識して仕事する。また、常に批判的な目で自らの仕事を評価する。
* いい加減な言い訳よりも対策を用意すること
    * 言い訳ではなく対策を用意する。「できない」などと言わずにできることを明確にする。
* 割れた窓を放置しておかないこと
    * まずい設計、誤った意志決定、貧弱なコードを見つけたら修正する。
* 変化の触媒たれ
    * 他人に変革を強制することはできない。そうではなく、未来を垣間見せ、その実現に参加できるよう手助けする。
* 大きな構想を忘れないようにすること
    * 詳細に入り込みすぎて、周囲の状況をおろそかにしてしまわないようにする。
* 品質要求を明確にすること
    * プロジェクトにおける真の品質要求を決定するためには、ユーザーを巻き込む。
* あなたの知識ポートフォリオに対して定期的な投資を行うこと
    * 学習を習慣づける。
* 見聞きしたものごとを批判的な目で分析すること
    * ベンダーの売り文句、マスコミの宣伝、独断的考えに惑わされない。
* 伝えることがらと、伝える方法は車の両輪だと考えること
    * うまく伝えることができなければ、良いアイデアも無意味である。
* DRY――Don't Repeat Yourself（繰り返しを避けること）
    * システム中のすべての知識は、重複なく、明瞭、信頼できる表現となっていなければならない。
* 再利用しやすいようにしておくこと
    * 容易に再利用できれば、皆がそれを使うはずである。再利用をサポートできる環境を構築する。
* 関係のないもの同士の影響を排除すること
    * 単独目的のうまく定義され、自己完結した独立コンポーネントを設計する。
* 最終決定などというものは存在しない
    * 石に刻み込まれるような決定はあり得ない。すべての決定を砂浜の砂に描かれたものと考え、変更に備えておく。
* 目標を見つけるには曳光弾を使うこと
    * 曳光弾を使えば、目標の補足と目標にどれだけ近く着弾したのかが判るようになる。
* プロトタイプの真の目的は学びにある
    * プロトタイピングとは、学習経験のことである。その価値は出来上がったコードにあるのではなく、学習した教訓そのものなのである。
* 問題領域に近いところでプログラミングを行うこと
    * ユーザーの言葉で設計、コーディングを行う。
* 後でびっくりしないために、見積もりを行うこと
    * 始める前に見積もりを行い、前もって潜在的な問題を洗いだしておく。
* 規律に従ってスケジュールを繰り返し、精度を向上させていくこと
    * プロジェクトの期間見積もりに磨きを掛けるには、その実装によって得た経験を用いる。
* 知識はプレインテキストに保存すること
    * プレインテキストは、廃れることがなく、デバッグやテストを簡潔にする強力な武器となり得る。
* コマンドシェルの力を使うこと
    * GUIが使えない場合はシェルを使う。
* 一つのエディタを熟知すること
    * エディタは手の延長となるべきであり、エディタが設定可能、拡張可能、プログラム可能であるかどうか、確認しておく。
* 常にソースコード管理システムを使用すること
    * ソースコード管理システムはあなたの仕事におけるタイムマシンであり、どんな過去にも戻ることができる。
* 非難するのではなく、問題を修復すること
    * バグの原因が誰にあるかは問題ではない――問題はあなたのものであり、あなたが解決しなければならないのである。
* パニックに陥らないこと
    * まず深呼吸をしてから、バグを引き起こした原因について考える。
* “select”はおかしくない
    * OSやコンパイラ、サードパーティの製品やライブラリーにバグがあることは希である。バグはたいていの場合アプリケーション側に存在する。
* 仮定せずに、証明すること
    * 実際の環境――つまり実際のデータと境界条件を用いて仮定を証明する。
* テキスト操作言語を学ぶこと
    * 毎日多くの時間をテキスト作業に割いているのなら、そういった作業をコンピュータにさせるべきである。
* コードを生成するコードを作成すること
    * コードジェネレータは、生産性と二重化を避けるための武器である。
* あなたは完璧なソフトウェアを作ることができない
    * ソフトウェアは完璧にはならない。このため、不可避のエラーからコードとユーザーを守る。
* 契約を用いて設計を行うこと
    * ドキュメントには契約の考え方を用い、コードがそれ以上のこともそれ以下のことも行わないことを検証する。
* 早めにクラッシュさせること
    * 中途半端に動いているプログラムは、停止したプログラムよりもたちが悪い。
* もし起こり得ないというのであれば、表明を用いてそれを保証すること
    * 仮定を検証するには表明を使用する。表明を用いて不確かな世界からコードを守る。
* 例外は例外的な問題のみに使用すること
    * 例外の使い方を誤ると、古典的なスパゲッティコードに起因するすべての可読性と保守性の問題が呼び込まれる。例外は例外的な場合にのみ用いる。
* 始めたことは終わらせること
    * リソースの解放は、可能な限りそのリソースを割り当てたルーチンやオブジェクトが責任を持って行うべきである。
* モジュール間の結合度を最小にすること
    * 「恥ずかしがりなコード」を記述し、デメテルの法則を適用することにより、結合度を低く抑える。
* 設定とすべきものを統合しないこと
    * 何でも統合してしまうのではなく、設定オプションを用いて必要なものをアプリケーションが選択できるようにする。
* 抽象概念はコード上に、詳細はメタデータ上に置くこと
    * 概念的なものをプログラムし、詳細はコンパイルされたコード中には記述しない。
* 並列性の改善にはワークフローを分析すること
    * ユーザーのワークフローにある並列性を活用する。
* サービスを使って設計を行うこと
    * サービス（整合性のあるインタフェースをうまく定義した、独立／並列動作可能なオブジェクト）を用いて設計を行う。
* 常に並列性を意識した設計を行うこと
    * 並列性を持たせることにより、仮定の少ないきれいなインタフェースを設計する。
* モデルからビューを分離すること
    * モデルとビューを用いてアプリケーションを設計することにより、安価で柔軟性の高い設計を目指す。
* ワークフローを協調させるためにはホワイトボードを使用すること
    * 独立性を保ったまま共通点のない事実やエージェントを協調させるには、ホワイトボードを使用する。
* 偶発的なプログラミングを行わないこと
    * 信頼のおけるもののみを信頼する。偶然の符合に注意し、当初の確固たる目的と偶然の一致を区別する。
* アルゴリズムのオーダーを見積もること
    * どのくらいかかるのか、コードを書き始める前に感じ取れるようにする。
* 見積もりの検証を行うこと
    * アルゴリズムの数学的分析で、すべてが判るわけではない。このため、対象としている環境で実際に測定する。
* 早めにリファクタリングすること、そしてこまめにリファクタリングすること
    * 庭の雑草取りや植物の再配置を行うのと同じように、必要に応じてコードの再記述、再作業、再アーキテクトを行う。そして問題の根本原因を修正する。
* テスト設計を行うこと
    * コードの記述を始める前にテストのことを考え始める。
* ソフトウェアをテストすること、さもなければユーザーにテストを強いることになる
    * 容赦ないテストを行う。ユーザーが先にバグを見つけることのないようにする。
* ウィザードの生成コードが理解できないのであれば、ウィザードを使わないこと
    * ウィザードを使えば大量のコードを生成できるが、そのすべてが理解できるまではプロジェクト中に組み入れない。
* 要求は拾い集めるものではなく、掘り起こすものである
    * 要求が見えるところに横たわっていることは希である。要求は、仮定、誤解、政策といった層に深く埋められているものである。
* ユーザーの視点に立つには、ユーザーと働くこと
    * システムの本当の使用方法について理解を得るにはこれが一番の方法である。
* 抽象は詳細よりも息が長いものである
    * 実装ではなく、抽象化に労力をつぎ込む。抽象は、異なった実装や新技術といったものに起因する集中砲火に耐えることができる。
* プロジェクトの用語集を作ること
    * プロジェクトが使用する特定の専門用語や語彙をまとめた用語集を作成、維持する。
* 枠にとらわれずに考えるのではなく、枠を見つけ出すこと
    * 不可能と思える問題に直面した場合、実際の制約を見抜く。「この手段でやり遂げなければならないのか？」「多少なりともの方法でやり遂げなければならないのか？」を自問する。
* 心の声に耳を傾け、準備ができてから開始すること
    * 長い人生で培ってきた経験を信じ、小さな疑いも無視しない。
* 解説しないほうがよい場合もある
    * 仕様の渦の中に巻き込まれず、どこかのタイミングでコーディングを開始する。
* 形式的方法論の奴隷になってはいけない
    * 実際の開発における実用性や能力といった観点を抜きにして、方法論を盲信してしまうことは避ける。
* 高価なツールが良い設計を生み出すとは限らない
    * ベンダーの誇大広告、業界の偏見、価格の高さに惑わされず、メリットでツールを評価する。
* 職務権限ではなく、機能によってチームを編成すること
    * 設計者、コーディング担当、テスト担当を分断してしまわない。コードのビルドと同じ方法でチームを編成する。
* 手作業は危険である
    * シェルスクリプトやバッチファイルを使えば同じ作業を同じ順序で何度でも実行できる。
* 早目にテスト、何度もテスト、自動でテスト
    * 毎回ビルドを行う度に実行されるテストは、棚にしまわれているテスト計画よりもずっと有効なものとなる。
* テストがすべて終わるまでコーディングは終わらない
    * これ以上、言うことなし。
* テストのテストをするには破壊工作を試みる
    * テストがうまく機能するかどうかを確認するには、目的に応じたバグをソースのコピーに混入してみる。
* コードのカバレージではなく、状態のカバレージをテストすること
    * テストは、重要なプログラムの状態を識別して行う。すべての行をテストしただけでは十分ではない。
* 複数のバグを一度に見つけること
    * テスト担当者がバグを見つけた場合、今後はもうそれと同種のバグをテスト担当者が見つけることのないようにする。以降は自動化されたテストにチェックさせる。
* 日本語をもう一つのプログラミング言語として扱うこと
    * コーディングを行うようにドキュメントを記述する。DRY原則を守り、メタデータ、MVC、コードの自動生成といった技法を使用する。
* ドキュメントは付け足すものではなく、組み込むものである
    * コードと別に作られたドキュメントは、正確性に劣り、すぐに陳腐化する。
* ユーザーの期待を少しだけ上回ること
    * ユーザーの期待を理解し、それよりも少し良いものを作る。
* あなたの作品に署名すること
    * 初期の職人が自らの成果物に誇りを持って署名したように、ソフトウェアに署名する。

#### 「付録C クイックリファレンスガイド」のチェックリストより

▷学ぶべき言語
C、C++、Javaに疲れたのですか？　ではCLOS、Dylan、Eiffel、Objective C、Prolog、Smalltalk、TOMを試してみましょう。これらの言語はそれぞれ異なった能力と、異なった「味わい」をもっています。こういった言語を使って、個人的にでも小さなプロジェクトを作ってみましょう。

▷合い言葉WISDOM
```
W 何(what)            聞き手に何を知ってほしいのか
I 興味(interest)      言いたいことの中にある彼らの興味とは何か
S 洗練(sophisticate)  それらはどれくらい洗練されているか
D 詳細(detail)        彼らはどの程度詳細を知りたがっているか
O 誰の情報(own)        誰にその情報を知ってもらいたいのか
M 動機づけ(motivate)   話を聞いてもらえるには、どうするのか
```

▷直交性
* 自己完結したコンポーネント、つまり独立し、単機能の、目的によく適合したコンポーネントを設計すること
* コードの結合度を最小化する
* グローバルデータを避ける
* 類似機能のリファクタリングを行う

▷プロトタイプの適用対象
* アーキテクチャ
* 既存システムに追加する新機能
* 外部データの構造や内容
* サードパーティのツールやコンポーネント
* パフォーマンスの問題
* ユーザーインタフェースの設計

▷アーキテクチャに関するチェックリスト
* 責任分担はうまく定義されているか？
* 協調関係はうまく定義されているか？
* 結合度は最小化されているか？
* 二重化の原因になりそうなものを識別できるか？
* インタフェース定義と制約は妥当なものか？
* モジュールが必要な時に必要なデータをアクセスできるか？

▷デバッグ時のチェックリスト
* 報告を受けた問題は、元となるバグの直接的な結果でしょうか、それとも単なる症状なのでしょうか？
* 本当にコンパイラのバグでしょうか？ OSのバグでしょうか？ あなたのコードのバグなのでしょうか？
* この問題を同僚に説明するとしたら、どのように説明すればよいでしょうか？
* 疑わしいコードが単体テストを終了していたのであれば、テストはちゃんと行われていたのでしょうか？ このデータを使って単体テストを実行していたなら、どうなっていたのでしょうか？
* このバグを発生させた条件が、システム内のどこか他の部分に残っていないでしょうか？

▷機能に対するデメテルの法則
* 自分自身
* メソッドに引き渡されたパラメータ
* 自身が生成したオブジェクト
* 直接保持しているコンポーネントオブジェクト

▷慎重なプログラミングの方法
* 常に何をやっているのかを意識すること
* 目隠しでコーディングしないこと
* 明確なプランから進めるようにすること
* 信頼のおけるものを前提とすること
* 仮定をドキュメント化すること
* 単にコードをテストするのではなく、あなたの仮定をテストすること
* 作業に優先順位をつけること
* 過去のしがらみにとらわれないこと

▷いつリファクタリングを行うべきか
* DRY原則に反しているものを発見した場合
* より直交性の高いコードや設計ができる場合
* 知識が増えた場合
* 要求が変更された場合
* パフォーマンスを向上させる必要がある場合

▷ゴルディアスの結び目を切る
* 不可能と思われる問題に直面した際のチェックリスト
* 簡単な手段は存在するのか？
* 正しい問題を解決しようとしているのか？
* なぜそれが問題なのか？
* 解決を難しくしている真の原因は何なのか？
* この手段でやり遂げなければならないのか？
* 多少なりともこの方法でやり遂げなければならないのか？

▷何をテストするか
* 単体テスト
* 統合テスト
* 妥当性確認および検証
* リソース消費、エラー、リカバリー
* パフォーマンステスト
* 利便性テスト
* テストのテスト

## これまでの総括

方針：

* 今、目先トレーニングを必要としている1年目の皆さんのためにまずは動きながら模索する
* 仮配属のフィードバックとして1年目の皆さんから出た
  「全員が知っておくべきことをもう少し体系的に学びたい」への1つの回答
* 所属チームが多様なので、まずはどのチームでも必要な基礎を重点的に
* 詳細は自分で学ぶ必要は認識してもらうとして、
  本やソフトウェアドキュメントに含まれているさまざまなテーマのうち、
  何は学ぶ必要があり、何はそこまで学ぶ必要がないか取捨選択できるようになるのをサポート
* テクニカルサークルや業務で、他人が話している言葉がしっかりイメージを持ってわかるようになるのをサポート

できたこと：

* R-DEViCo Week以外毎週実施による継続的な学習
* Git / GitHubはある程度は使えてきている？
* データがサーバで作られてHTTPを通して外に出ていく過程のイメージや
  具体的な道具はつかんでもらえた？
* データフォーマットまわりはかなり体系的に学んだので、
  共通で使いそうなフォーマットは概ね扱えるはず
* 社内の知識に特化した教材の作成
  * 「一度話を聞いてある程度理解はできたので、使うときに教材を見直せる」

課題点：

* 業務が開発（実装）ではないメンバーも半分くらいいるので、
  講義＆ハンズオンの時間以外に手を動かすことにはつながっていない
* 教材作成の負荷

今後の案：

* 「体系的な知識」に関して、小林以外に話をしてもらう時間を作る？
  * 候補は何人かいるが、小林が全員把握しているとも思えないのでやり方は要検討
  * 残っているテーマは色々あるが、実ニーズの高いものからやる？
    * PM/レビュー
    * Instructure as Code (Ansible)
    * さまざまな処理の協調
    * 可視化
    * データベースやストレージ
* ZUKKOKEなど、自分で考えてもらう時間を増やす？
* コードの読み書きをする時間を増やしたい
  * 読み：よいコードは探し中
  * 書き：自分の業務でテーマを見つけられるのがベスト

## 議論

* 参加者の皆さん（基本的には1年目）の実務
* 今後身につけたいこと
* 今後の進め方
* テーマ
