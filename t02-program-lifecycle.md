# プログラムのライフサイクル -- プロセス、デーモン、サーバ、クライアント、インジェクション攻撃

## 概要

今回はプログラムがどこでどう動いているのか、お話します。
「○○言語プログラミング入門」のような本や講座で、
文法の理解やプログラムを書くイメージは何となくできると思いますが、
プログラムがどこでどのように動いているのか、
もしかしたらイメージが湧いていないかもしれません。
今回は、それらのイメージができ、サーバやインジェクション攻撃などの
理解ができるようになることを目指します。

ハンズオンの環境としてDocker環境（docker-compose含む）を使うので、
事前準備としてDockerをインストールしてきてくださると助かります（「事前準備」参照）。

### 本日お話すること

* はじめに：Dockerという道具の使い方（おまじない）の説明
  * 目的ではなく環境構築の手段！！
  * 事前準備：Docker自体の実行環境の構築
  * Dockerを使った「マシン」の起動かあら終了まで
  * Dockerを使うときの注意点
* プロセスを見てみる
* シバン (shebang) を理解する
* 同じプログラムを複数実行してみる
* プロセスを外部から終了させる
* 常駐プログラム、デーモン、サーバ
  * 常駐プログラムの罠
* WebサーバでCGIを動かしてブラウザからアクセスしてみる
* Webアプリケーションにブラウザからアクセスしてみる
* 「世界最悪のログイン処理コード」の世界を理解する


## はじめに：Dockerという道具の使い方

### 目的ではなく環境構築の手段！！

今回は、Docker環境を使って色々動かしていく。
といっても、目的はDockerについて学ぶことでもDockerを使いこなすことでもない。
目的はあくまで、プロセスを眺めたり、サーバを使ってみたりすること。
だから、「Dockerを使うんだ」と何か特別なことをするかのように身構えないでほしい。
「1台、自分専用の別のマシンを買ってもらった」程度に思ってほしい。
当然、「自分の開発するシステムでもDockerを使ったほうがよい」などと思わなくてよい。

本トレーニングでDockerを使う理由：

* 個々人が自由にいじれる使い捨てのサーバ環境を用意できる
* サーバを用意するのにC-Centerに依頼したりSSH公開鍵を用意したりする必要がない
* 個々人のローカル環境（ノートPC内）にいくつでもサーバを立てられる
  * 社内ネットワークに繋がっていなくても使える
  * オフラインでも使える
* 同じ `Dockerfile` を使えば同じ環境が用意できる（はず）

Dockerは、あくまでこれらの条件を満たす道具にすぎない。
なので、Docker自体はブラックボックスと思って、何か詰まったらさっさと相談しよう。


### 事前準備：Docker自体の実行環境の構築

個々人の環境内で「サーバ」を作ってもらうのにDockerを使うので、
dockerコマンドおよびdocker-composeコマンドが使える状態にしましょう。

Macの場合はDocker Desktop for Macを入れると両方とも入ります。
[こちら](https://docs.docker.com/docker-for-mac/install/)
からインストールしてください
（2019年7月ごろからユーザアカウントが求められるようになったので、
作成してください）。

Windowsまわりは複数選択肢があります。
可能ならDocker for Windowsをインストールするのがよいですが、
Docker for Windowsが入らない環境の場合はDocker Toolboxを入れてください
（質問があればC-Center村上（翔）さんまで）。


### Dockerを使った「マシン」の起動かあら終了まで

以下は、`docker-compose.yml`が存在するディレクトリかその下位にあるディレクトリで行う。

`docker-compose.yml`がどこかというのはあとで具体的な操作をしていくときに書く。
ここはあくまで一般論。

#### 起動

「マシン」の起動には下記コマンドを実行する。

```
% docker-compose up --build -d
Building host_a
Step 1/4 : FROM nginx
 ---> b175e7467d66
(...)
Successfully built 8f8de89ea6e6
Successfully tagged t02-hosts_host_a:latest
Creating t02-hosts_host_a_1 ... done
```

必要に応じてインターネットから色々ダウンロードしてきて、勝手に構築してくれる。
必要がなければ（以前落としたときと変化がなければ）構築はスキップしてくれる。
最後に`done`と表示されたら起動完了。

#### 状態をチェック

`docker-compose.yml`に記載された「マシン」群が起動しているかを確認する。
以下は`host_a`という1つしか`docker-compose.yml`にない場合の例。

```
% docker-compose ps
       Name                Command          State           Ports
-------------------------------------------------------------------------
t02-hosts_host_a_1   nginx -g daemon off;   Up      0.0.0.0:10080->80/tcp
```

`State`が`Up`であれば起動中。
使い終わったら落としておいたほうがよい。

#### ログイン

マシンへのログインには下記コマンドを使う。

```
% docker-compose exec -u foo <マシン名> /bin/bash
```

* マシン名は、これまでの説明の場合なら`host_a`
* 構築時に`foo`というアカウントを作るようになっており、
  このコマンドではそのアカウントで入るよう指定している

#### 停止

マシンの停止には下記コマンドを使う。

```
% docker-compose down
Stopping t02-hosts_host_a_1 ... done
Removing t02-hosts_host_a_1 ... done
```

### Dockerを使うときの注意点

以下で、「外の世界」とはローカル環境（Dockerを実行しているノートPC）を指す。
また「Docker環境」とは、上の「マシン」と同義。

* 落としたときに、「外の世界」と繋がっていない変更はすべて消える
* 「外の世界」のファイルが扱えないと不便なので、
  例では、「外の世界」の一部のディレクトリをDocker環境のディレクトリとして
  アクセスできるようにしている。
  そのような場合、Docker内でそのディレクトリに含まれているファイルを削除したら、
  外の世界でも削除されてしまう。
* 例では10080番などのポートを使っているが、もしかしたら、
  自分が普段の開発作業などで使っているポートと被るかもしれない。
  被っている場合は変えること
  （「ポート」と聞いてわからない人もいるかもしれないが、
  たぶん、そのようなことをしている人はこの説明で通じるはず）。

## プロセスを見てみる

プログラミングを勉強し始めた人なら誰でも、
プログラムはファイルに保存しただけでは動かず、
コマンドラインなどから叩くなどして **実行** して初めて動くことを知っている。

実行して動くのは、自分で書いたプログラムだけでない、
コマンドラインから実行するすべてのコマンド（`ls`など）も同じ
（実は`cd`など違うものもあるけど、混乱するので説明は省略）。

実行したときに、プログラムはメモリに読み込まれ、実行されるかたちになる。
それを **プロセス** と呼ぶ。
動いているプロセスは、`ps`コマンドや`top`コマンドで表示できる
（`ps`コマンドはデフォルトだと一部のプロセスしか表示されず、
知りたい情報が網羅されないことが多いため、通常は`ps auxww`のかたちで用いる）。
オプションを変えて試してみるとよい。

プロセスは、1回起動し、実行が終了したら消えてなくなる。
具体的には、プロセスのために使われていたメモリをOSが回収し、
ほかのプロセスが起動したときに割り当てる。

ハンズオン：
* 準備：今回の教材を手に入れる
* 演習1：プロセスを眺めてみる


## シバン (shebang) を理解する

スクリプトの1行目に、`#!/usr/bin/python3`などと書かれていることがよくある。
このような「おまじない」をシバン (shebang) という。
これは、「そのスクリプトがどのプログラムで実行されるか」を表す。

ハンズオン：
* 演習2：シバンによる動作の違いを見てみる


## 同じプログラムを複数実行してみる

プログラムファイル（スクリプト）は1つでも、プロセスは同時に複数起動できる。
わかりやすい例がシェルだろう。
複数のターミナルを立ち上げればそれらのそれぞれで`/bin/bash`（のプロセス）が走っている。
しかし、`/bin/bash`というプログラムファイルは1つしかない。

すべてのプロセスにはPIDという番号がついており、
OSはその識別子でそれぞれのプロセスを管理している。
同じプログラムを複数実行した場合、プログラムは一緒だが、PIDは異なる。

ハンズオン：
* 演習3：同じプログラムを複数実行してみる


## プロセスを外部から終了させる

動いているプログラム（プロセス）に対して、外部から信号を送ることができる。
これを **シグナル** という。

プログラムは基本的に、書かれた命令を順に実行していって、
プログラムファイルの最後に達したら実行が終わる（ざっくりとした説明だが）。
ただ、場合によっては、「終わらないプログラム」などもある。
そういったプログラムを終了するのにこのシグナルがよく用いられる。

たとえば、無限ループのプログラムを止めるために使っている`control + C`は、
シグナルを送るショートカットである。
しかしこのショートカットは、
そのプログラム（プロセス）をキーボードから実行している場合（厳密な説明は省略）しか送れない。
もっと汎用的に、
PIDを指定して任意のプロセスに対してシグナルを送るためのコマンドとして`kill`がある。

OSを終了するときも、動いているプロセスに対してシグナルが送られ、
それぞれのプロセスが正常に終了するための猶予が与えられる。

なお、「シグナル」と一言で言っても、実は様々なものがあるが、
多分WNIでは`kill`などで使う以外、直接意識することは少ないと思うので、触れない。

ハンズオン：
* 演習4：プロセスにシグナルを送ってみる
* 演習5：プロセスをシグナルでサスペンドしてみる


## 常駐プログラム、デーモン、サーバ

無限ループのプログラムを止めるためにシグナルを使うという話をした。
世の中には、バグで無限ループになってしまったプログラムだけでなく、
意図的に無限ループになっているプログラムがある。
「常駐プログラム」という言い方をしたりする。

その中でも特に世の中にとって重要なのが、
サービスを提供するプログラム、要は **サーバ（サーバプログラム）** である。

* Webサーバ：アクセスが来たときにHTML等を返さないといけない
* メールサーバ：メールが送られてきたときに転送などをしないといけない
* DNSサーバ：weathernews.jpなどと言われたときにIPアドレスを返さないといけない
* NTPサーバ：時刻合わせのリクエストに応答しないといけない

など、サーバプログラムは24時間365日動いていないといけない。
要は、ユーザからのリクエストに対応できるよう、常に無限ループしながら待ち受けている。

サーバプログラムは、「〜d」という名前になっていることが多い。
たとえば以下は、とあるサーバ（ホスト）で`ps auxww`を実行した結果である。

```
USER       PID   %CPU %MEM   VSZ  RSS TT  STAT STARTED           TIME COMMAND
(...)
root       581    0.0  0.0 16704  360  -  Is   23Jun17        0:00.00 /usr/sbin/moused -p /dev/ums0 -t auto -I /var/run/moused.ums0.pid
root       598    0.0  0.0 13164 1352  -  Ss   23Jun17        0:42.17 /sbin/devd
root       747    0.0  0.0 14492  684  -  Ss   23Jun17        3:58.25 /usr/sbin/syslogd -s
root       841    0.0  0.0 25448  952  -  Ss   23Jun17       62:19.11 /usr/sbin/ntpd -c /etc/ntp.conf -p /var/run/ntpd.pid -f /var/db/ntpd.drift
root       878    0.0  0.0 61204 1200  -  Ss   23Jun17       21:56.96 /usr/sbin/sshd
```

この「d」は「デーモン」の意味である。
inetd、tcpd、httpd、ftpd、smtpd、imapd、dhcpd、smbd、ntpd、sshdなど、
サービス名やプロトコル名に「d」がつけられているものが多い。
多くはOSに標準で装備されてきたので、わざわざ名前を変えることもなかった。

とはいえ、Webサーバ、つまりHTTPサーバなどは、
現在は様々な実装が存在し、ユーザが自分のニーズに適したものを選べる。
たとえば、Apache HTTP ServerやNginxなどである。

### 常駐プログラムの罠

ずっと動き続けるプログラムには、
「プログラムを変更しても、起動しなおさないと反映されない」という罠がある。
また、プログラムが読み込むファイルについても、
「最初に読んだ後は、明示的に示されない限り読み込み直さない」ことが多い。

たとえば、1秒間に何百ものリクエストに答えなければいけないときに、
リクエストが来るたびに「設定ファイルが更新されていないかチェック」などとやっていたら、
とても反応できない、というのは何となくわかるはずだ。

* 演習6：プログラムを書き換えてみる
